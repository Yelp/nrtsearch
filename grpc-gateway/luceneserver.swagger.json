{
  "swagger": "2.0",
  "info": {
    "title": "yelp/nrtsearch/luceneserver.proto",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/status/metrics": {
      "get": {
        "summary": "metrics",
        "operationId": "LuceneServer_metrics",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/add_documents": {
      "post": {
        "summary": "Adds a stream of Documents",
        "operationId": "LuceneServer_addDocuments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": " (streaming inputs)",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/backup_index": {
      "post": {
        "summary": "backs up a resource (index) and it associated metadata e.g. settings, schema to s3",
        "operationId": "LuceneServer_backupIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBackupIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBackupIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/backup_warming_queries": {
      "post": {
        "summary": "Backup warming queries to S3",
        "operationId": "LuceneServer_backupWarmingQueries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBackupWarmingQueriesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBackupWarmingQueriesRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/commit": {
      "post": {
        "summary": "Commits all pending changes to durable storage",
        "operationId": "LuceneServer_commit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCommitResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCommitRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/create_index": {
      "post": {
        "summary": "Create an Index",
        "operationId": "LuceneServer_createIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCreateIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCreateIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/create_snapshot": {
      "post": {
        "summary": "Creates a snapshot in the index, which is saved point-in-time view of the last commit\nin the index such that no files referenced by that snapshot will be deleted by ongoing\nindexing until the snapshot is released with @releaseSnapshot.  Note that this will\nreference the last commit, so be sure to call commit first if you have pending changes\nthat you'd like to be included in the snapshot.\nThis can be used for backup purposes, i.e. after creating the snapshot you can copy\nall referenced files to backup storage, and then release the snapshot once complete.\nTo restore the backup, just copy all the files back and restart the server.\nIt can also be used for transactional purposes, i.e. if you sometimes need to search a\nspecific snapshot instead of the current live index. Creating a snapshot is very fast\n(does not require any file copying), but over time it will consume extra disk space as\nold segments are merged in the index.  Be sure to release the snapshot once you're done.\nSnapshots survive shutdown and restart of the server.  Returns all protected filenames\nreferenced by this snapshot: these files will not change and will not be deleted until\nthe snapshot is released.  This returns the directories and files referenced by the snapshot.",
        "operationId": "LuceneServer_createSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCreateSnapshotResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCreateSnapshotRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete": {
      "post": {
        "summary": "Delete documents",
        "operationId": "LuceneServer_delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_all": {
      "post": {
        "summary": "Delete all documents for index",
        "operationId": "LuceneServer_deleteAll",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteAllDocumentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteAllDocumentsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_by_query": {
      "post": {
        "summary": "Delete documents matching a query",
        "operationId": "LuceneServer_deleteByQuery",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteByQueryRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_index": {
      "post": {
        "summary": "Delete index",
        "operationId": "LuceneServer_deleteIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_index_backup": {
      "post": {
        "operationId": "LuceneServer_deleteIndexBackup",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexBackupResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexBackupRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/force_merge": {
      "post": {
        "summary": "Forces merge policy to merge segments until there are \u003c= maxNumSegments. The actual\nmerges to be executed are determined by the MergePolicy. This call will merge those\nsegments present in the index when the call started. If other threads are still\nadding documents and flushing segments, those newly created segments will not be\nmerged unless you call forceMerge again.",
        "operationId": "LuceneServer_forceMerge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/force_merge_deletes": {
      "post": {
        "summary": "Forces merging of all segments that have deleted documents. The actual merges to be\nexecuted are determined by the MergePolicy. For example, the default TieredMergePolicy\nwill only pick a segment if the percentage of deleted docs is over 10%.\nThis method first flushes a new segment (if there are indexed documents), and applies\nall buffered deletes.",
        "operationId": "LuceneServer_forceMergeDeletes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeDeletesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeDeletesRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/get_all_snapshot_index_gen/{indexName}": {
      "get": {
        "summary": "Gets all unreleased index gens of snapshots previously created with @createSnapshot.",
        "operationId": "LuceneServer_getAllSnapshotIndexGen",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverGetAllSnapshotGenResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/indices": {
      "get": {
        "summary": "indices",
        "operationId": "LuceneServer_indices",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverIndicesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/live_settings": {
      "post": {
        "summary": "Change global offline or online settings for this index.",
        "operationId": "LuceneServer_liveSettings",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/ready": {
      "get": {
        "summary": "Checks if a node is ready to receive traffic by checking if all the indices (which can be preloaded)\nare started. Can specify comma-separated list of index name to only check specific indices if needed.",
        "operationId": "LuceneServer_ready",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexNames",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/ready/{indexNames}": {
      "get": {
        "summary": "Checks if a node is ready to receive traffic by checking if all the indices (which can be preloaded)\nare started. Can specify comma-separated list of index name to only check specific indices if needed.",
        "operationId": "LuceneServer_ready2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexNames",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/refresh": {
      "post": {
        "summary": "Refresh the latest searcher for an index",
        "operationId": "LuceneServer_refresh",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverRefreshResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverRefreshRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/register_fields": {
      "post": {
        "summary": "Registers one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).\nPass a list of Fields and an indexName. Any number of fields may be registered in a single request,\nand once a field is registered it cannot be changed (write-once).\nThis returns the full set of fields currently registered.",
        "operationId": "LuceneServer_registerFields",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/release_snapshot": {
      "post": {
        "summary": "releases a snapshot previously created with @createSnapshot.",
        "operationId": "LuceneServer_releaseSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverReleaseSnapshotResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverReleaseSnapshotRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/search": {
      "post": {
        "summary": "Search",
        "operationId": "LuceneServer_search",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSearchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSearchRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/settings": {
      "post": {
        "summary": "Change global offline settings for this index.\nThis returns the currently set settings; pass no settings changes to retrieve current settings.",
        "operationId": "LuceneServer_settings",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/start_index": {
      "post": {
        "summary": "Starts an index",
        "operationId": "LuceneServer_startIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/state": {
      "post": {
        "summary": "Gets the state of a started index, includes settings, live_settings, search schema, suggest schema",
        "operationId": "LuceneServer_state",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/state/{indexName}": {
      "get": {
        "summary": "Gets the state of a started index, includes settings, live_settings, search schema, suggest schema",
        "operationId": "LuceneServer_state2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stats": {
      "post": {
        "summary": "Retrieve index statistics",
        "operationId": "LuceneServer_stats",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStatsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStatsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stats/{indexName}": {
      "get": {
        "summary": "Retrieve index statistics",
        "operationId": "LuceneServer_stats2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStatsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/status": {
      "get": {
        "summary": "healthcheck",
        "operationId": "LuceneServer_status",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "check",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stop_index": {
      "post": {
        "summary": "Stops an index",
        "operationId": "LuceneServer_stopIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDummyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStopIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/suggest_build": {
      "post": {
        "summary": "Builds a new auto-suggester, loading suggestions via the provided local file path.",
        "operationId": "LuceneServer_buildSuggest",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/suggest_lookup": {
      "post": {
        "summary": "Perform an auto-suggest lookup.",
        "operationId": "LuceneServer_suggestLookup",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSuggestLookupResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSuggestLookupRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/suggest_update": {
      "post": {
        "summary": "Updates existing suggestions, if the suggester supports near-real-time changes.",
        "operationId": "LuceneServer_updateSuggest",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/update_fields": {
      "post": {
        "summary": "Adds one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).\nPass a list of Fields and an indexName. Any number of fields may be registered in a single request,\nand once a field is registered it cannot be changed (write-once).\nThis returns the full set of fields currently registered.",
        "operationId": "LuceneServer_updateFields",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/search": {
      "post": {
        "summary": "Search V2",
        "operationId": "LuceneServer_searchV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protobufAny"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSearchRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    }
  },
  "definitions": {
    "AddDocumentRequestMultiValuedField": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "faceHierarchyPaths": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacetHierarchyPath"
          },
          "title": "Facet paths/hierarchy to bucket these values by, if indexed field is of type Facet.HIERARCHY"
        }
      },
      "description": "we use this wrapper object to represent each field as a multivalued field."
    },
    "BooleanClauseOccur": {
      "type": "string",
      "enum": [
        "SHOULD",
        "MUST",
        "FILTER",
        "MUST_NOT"
      ],
      "default": "SHOULD",
      "description": "Defines how clauses may occur in matching documents. This will always be SHOULD by default."
    },
    "BucketResultBucket": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "HitCompositeFieldValue": {
      "type": "object",
      "properties": {
        "fieldValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HitFieldValue"
          }
        }
      }
    },
    "HitFieldValue": {
      "type": "object",
      "properties": {
        "textValue": {
          "type": "string"
        },
        "booleanValue": {
          "type": "boolean"
        },
        "intValue": {
          "type": "integer",
          "format": "int32"
        },
        "longValue": {
          "type": "string",
          "format": "int64"
        },
        "floatValue": {
          "type": "number",
          "format": "float"
        },
        "doubleValue": {
          "type": "number",
          "format": "double"
        },
        "latLngValue": {
          "$ref": "#/definitions/typeLatLng"
        },
        "structValue": {
          "type": "object"
        }
      }
    },
    "NestedQueryScoreMode": {
      "type": "string",
      "enum": [
        "NONE",
        "AVG",
        "MAX",
        "MIN",
        "SUM"
      ],
      "default": "NONE"
    },
    "ProfileResultAdditionalCollectorStats": {
      "type": "object",
      "properties": {
        "collectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Sum of all collection time"
        }
      }
    },
    "ProfileResultCollectorStats": {
      "type": "object",
      "properties": {
        "terminated": {
          "type": "boolean",
          "description": "If collection for this index slice was terminated early, such as by a timeout."
        },
        "segmentStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProfileResultSegmentStats"
          }
        },
        "totalCollectedCount": {
          "type": "integer",
          "format": "int32",
          "title": "Total docs collected by this collector"
        },
        "totalCollectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Sum of all segment collection time"
        },
        "additionalCollectorStats": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ProfileResultAdditionalCollectorStats"
          },
          "title": "Stats for additional collection operations"
        }
      }
    },
    "ProfileResultSearchStats": {
      "type": "object",
      "properties": {
        "totalCollectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Total time for all document collection"
        },
        "totalReduceTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Total time to reduce results from all parallel search slices"
        },
        "collectorStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProfileResultCollectorStats"
          }
        }
      }
    },
    "ProfileResultSegmentStats": {
      "type": "object",
      "properties": {
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "title": "Total docs in segment"
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Total live docs in segment"
        },
        "collectedCount": {
          "type": "integer",
          "format": "int32",
          "title": "How many docs were collected"
        },
        "relativeStartTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Start time of segment processing in relation to the start of the search phase"
        },
        "collectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Collection duration"
        }
      }
    },
    "ScriptParamListValue": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptParamValue"
          }
        }
      },
      "title": "list parameter value"
    },
    "ScriptParamNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "title": "null parameter value"
    },
    "ScriptParamStructValue": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ScriptParamValue"
          }
        }
      },
      "title": "map parameter value"
    },
    "ScriptParamValue": {
      "type": "object",
      "properties": {
        "textValue": {
          "type": "string"
        },
        "booleanValue": {
          "type": "boolean"
        },
        "intValue": {
          "type": "integer",
          "format": "int32"
        },
        "longValue": {
          "type": "string",
          "format": "int64"
        },
        "floatValue": {
          "type": "number",
          "format": "float"
        },
        "doubleValue": {
          "type": "number",
          "format": "double"
        },
        "nullValue": {
          "$ref": "#/definitions/ScriptParamNullValue"
        },
        "listValue": {
          "$ref": "#/definitions/ScriptParamListValue"
        },
        "structValue": {
          "$ref": "#/definitions/ScriptParamStructValue"
        }
      },
      "title": "script parameter entry"
    },
    "SearchResponseDiagnostics": {
      "type": "object",
      "properties": {
        "parsedQuery": {
          "type": "string",
          "title": "Query debug has been moved to ProfileResult"
        },
        "rewrittenQuery": {
          "type": "string"
        },
        "drillDownQuery": {
          "type": "string"
        },
        "firstPassSearchTimeMs": {
          "type": "number",
          "format": "double"
        },
        "highlightTimeMs": {
          "type": "number",
          "format": "double"
        },
        "getFieldsTimeMs": {
          "type": "number",
          "format": "double"
        },
        "newSnapshotSearcherOpenMs": {
          "type": "number",
          "format": "double"
        },
        "nrtWaitTimeMs": {
          "type": "number",
          "format": "double"
        },
        "facetTimeMs": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "double"
          }
        },
        "rescoreTimeMs": {
          "type": "number",
          "format": "double"
        },
        "rescorersTimeMs": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "double"
          }
        }
      }
    },
    "SearchResponseHit": {
      "type": "object",
      "properties": {
        "luceneDocId": {
          "type": "integer",
          "format": "int32"
        },
        "score": {
          "type": "number",
          "format": "double"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitCompositeFieldValue"
          }
        },
        "sortedFields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitCompositeFieldValue"
          }
        }
      }
    },
    "SearchResponseSearchState": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "searcherVersion": {
          "type": "string",
          "format": "int64"
        },
        "lastDocId": {
          "type": "integer",
          "format": "int32"
        },
        "lastFieldValues": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "lastScore": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "TermInSetQueryDoubleTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      }
    },
    "TermInSetQueryFloatTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      }
    },
    "TermInSetQueryIntTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "TermInSetQueryLongTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "TermInSetQueryTextTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "TotalHitsRelation": {
      "type": "string",
      "enum": [
        "EQUAL_TO",
        "GREATER_THAN_OR_EQUAL_TO"
      ],
      "default": "EQUAL_TO",
      "description": "* How the {TotalHits#value} should be interpreted.\n\n - EQUAL_TO: The total hit count is equal to {@link TotalHits#value}.\n - GREATER_THAN_OR_EQUAL_TO: The total hit count is greater than or equal to {@link TotalHits#value}."
    },
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "content_type": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody) returns\n      (google.protobuf.Empty);\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "luceneserverAddDocumentRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AddDocumentRequestMultiValuedField"
          }
        }
      }
    },
    "luceneserverAddDocumentResponse": {
      "type": "object",
      "properties": {
        "genId": {
          "type": "string"
        },
        "primaryId": {
          "type": "string",
          "title": "Unique identifier for the primary instance that processed the request"
        }
      }
    },
    "luceneserverAddReplicaResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string"
        }
      }
    },
    "luceneserverAnalyzer": {
      "type": "object",
      "properties": {
        "predefined": {
          "type": "string"
        },
        "custom": {
          "$ref": "#/definitions/luceneserverCustomAnalyzer"
        }
      }
    },
    "luceneserverAnalyzingSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        },
        "maxSurfaceFormsPerAnalyzedForm": {
          "type": "integer",
          "format": "int32"
        },
        "maxGraphExpansions": {
          "type": "integer",
          "format": "int32"
        },
        "preserveSep": {
          "type": "boolean"
        },
        "exactFirst": {
          "type": "boolean"
        }
      },
      "title": "Suggester that first analyzes the surface form, adds the analyzed form to a weighted FST, and then does the same thing at lookup time (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester"
    },
    "luceneserverBackupIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "resourceName": {
          "type": "string"
        },
        "completeDirectory": {
          "type": "boolean"
        },
        "stream": {
          "type": "boolean"
        }
      }
    },
    "luceneserverBackupIndexResponse": {
      "type": "object",
      "properties": {
        "dataVersionHash": {
          "type": "string"
        },
        "metadataVersionHash": {
          "type": "string"
        }
      }
    },
    "luceneserverBackupWarmingQueriesRequest": {
      "type": "object",
      "properties": {
        "index": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "numQueriesThreshold": {
          "type": "integer",
          "format": "int32"
        },
        "uptimeMinutesThreshold": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverBackupWarmingQueriesResponse": {
      "type": "object"
    },
    "luceneserverBooleanClause": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "occur": {
          "$ref": "#/definitions/BooleanClauseOccur"
        }
      },
      "description": "A clause in a BooleanQuery."
    },
    "luceneserverBooleanQuery": {
      "type": "object",
      "properties": {
        "clauses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverBooleanClause"
          }
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32"
        }
      },
      "description": "A query that matches documents using boolean combinations of other queries."
    },
    "luceneserverBucketResult": {
      "type": "object",
      "properties": {
        "buckets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BucketResultBucket"
          }
        },
        "totalBuckets": {
          "type": "integer",
          "format": "int32",
          "description": "Number of unique buckets, including those not in the buckets list."
        },
        "totalOtherCounts": {
          "type": "integer",
          "format": "int32",
          "description": "Number of other collected counts not represented in the buckets' counts."
        }
      }
    },
    "luceneserverBuildSuggestRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "infixSuggester": {
          "$ref": "#/definitions/luceneserverInfixSuggester",
          "title": "A suggester that matches terms anywhere in the input text, not just as a prefix. (see @lucene:org:server.InfixSuggester)"
        },
        "analyzingSuggester": {
          "$ref": "#/definitions/luceneserverAnalyzingSuggester",
          "title": "Suggester that first analyzes the surface form, adds the analyzed form to a weighted FST, and then does the same thing at lookup time (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester"
        },
        "fuzzySuggester": {
          "$ref": "#/definitions/luceneserverFuzzySuggester",
          "title": "Implements a fuzzy AnalyzingSuggester (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.FuzzySuggester"
        },
        "completionInfixSuggester": {
          "$ref": "#/definitions/luceneserverCompletionInfixSuggester",
          "title": "A suggester that matches terms anywhere in the input text. The implementation is different from InfixSuggester"
        },
        "fuzzyInfixSuggester": {
          "$ref": "#/definitions/luceneserverFuzzyInfixSuggester",
          "description": "A suggester that matches fuzzy terms in the input text."
        },
        "localSource": {
          "$ref": "#/definitions/luceneserverSuggestLocalSource"
        },
        "nonLocalSource": {
          "$ref": "#/definitions/luceneserverSuggestNonLocalSource"
        },
        "suggestName": {
          "type": "string"
        }
      }
    },
    "luceneserverBuildSuggestResponse": {
      "type": "object",
      "properties": {
        "sizeInBytes": {
          "type": "string",
          "format": "int64"
        },
        "count": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "luceneserverCollector": {
      "type": "object",
      "properties": {
        "terms": {
          "$ref": "#/definitions/luceneserverTermsCollector",
          "description": "Collector for aggregating based on term values."
        }
      },
      "description": "Definition of additional document collector."
    },
    "luceneserverCollectorResult": {
      "type": "object",
      "properties": {
        "bucketResult": {
          "$ref": "#/definitions/luceneserverBucketResult",
          "description": "Result of collector that produces buckets and counts."
        }
      }
    },
    "luceneserverCommitRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverCommitResponse": {
      "type": "object",
      "properties": {
        "gen": {
          "type": "string",
          "format": "int64",
          "description": "sequence number of the last operation in the commit.  All sequence numbers less than this value\nwill be reflected in the commit, and all others will not."
        },
        "primaryId": {
          "type": "string",
          "title": "Unique identifier for the primary instance that processed the request"
        }
      }
    },
    "luceneserverCompletionInfixSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        }
      },
      "title": "A suggester that matches terms anywhere in the input text. The implementation is different from InfixSuggester"
    },
    "luceneserverConditionalTokenFilter": {
      "type": "object",
      "properties": {
        "condition": {
          "$ref": "#/definitions/luceneserverNameAndParams"
        },
        "tokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          }
        }
      }
    },
    "luceneserverCopyState": {
      "type": "object",
      "properties": {
        "infoBytesLength": {
          "type": "integer",
          "format": "int32"
        },
        "infoBytes": {
          "type": "string",
          "format": "byte"
        },
        "gen": {
          "type": "string",
          "format": "int64"
        },
        "version": {
          "type": "string",
          "format": "int64"
        },
        "filesMetadata": {
          "$ref": "#/definitions/luceneserverFilesMetadata"
        },
        "completedMergeFilesSize": {
          "type": "integer",
          "format": "int32"
        },
        "completedMergeFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "primaryGen": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "Holds incRef'd file level details for one point-in-time segment infos on the primary node."
    },
    "luceneserverCreateIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      },
      "title": "Input to createIndex"
    },
    "luceneserverCreateIndexResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Response from Server to createIndex"
    },
    "luceneserverCreateSnapshotRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "openSearcher": {
          "type": "boolean"
        }
      },
      "description": "Creates a snapshot in the index, which is saved point-in-time view of the last commit in the\nindex such that no files referenced by that snapshot will be deleted by ongoing indexing until\nthe snapshot is released with @releaseSnapshot.  Note that this will reference the last commit,\nso be sure to call commit first if you have pending changes that you'd like to be included in\nthe snapshot.\u003cp\u003eThis can be used for backup purposes, i.e. after creating the snapshot you can\ncopy all referenced files to backup storage, and then release the snapshot once complete.\nTo restore the backup, just copy all the files back and restart the server.  It can also\nbe used for transactional purposes, i.e. if you sometimes need to search a specific snapshot\ninstead of the current live index.\u003cp\u003eCreating a snapshot is very fast (does not require any\nfile copying), but over time it will consume extra disk space as old segments are merged in\nthe index.  Be sure to release the snapshot once you're done.  Snapshots survive shutdown\nand restart of the server.  Returns all protected filenames referenced by this snapshot:\nthese files will not change and will not be deleted until the snapshot is released.\nThis returns the directories and files referenced by the snapshot."
    },
    "luceneserverCreateSnapshotResponse": {
      "type": "object",
      "properties": {
        "indexFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "taxonomyFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "stateFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "snapshotId": {
          "$ref": "#/definitions/luceneserverSnapshotId"
        }
      }
    },
    "luceneserverCustomAnalyzer": {
      "type": "object",
      "properties": {
        "charFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          }
        },
        "tokenizer": {
          "$ref": "#/definitions/luceneserverNameAndParams"
        },
        "tokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          }
        },
        "conditionalTokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverConditionalTokenFilter"
          }
        },
        "defaultMatchVersion": {
          "type": "string"
        },
        "positionIncrementGap": {
          "$ref": "#/definitions/luceneserverIntObject"
        },
        "offsetGap": {
          "$ref": "#/definitions/luceneserverIntObject"
        }
      }
    },
    "luceneserverDeleteAllDocumentsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverDeleteAllDocumentsResponse": {
      "type": "object",
      "properties": {
        "genId": {
          "type": "string"
        }
      }
    },
    "luceneserverDeleteByQueryRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "query": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverQuery"
          }
        }
      }
    },
    "luceneserverDeleteIndexBackupRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "resourceName": {
          "type": "string"
        },
        "nDays": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverDeleteIndexBackupResponse": {
      "type": "object",
      "properties": {
        "deletedResourceDataHashes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deletedResourceMetadataHashes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deletedDataVersions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deletedMetadataVersions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverDeleteIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverDeleteIndexResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string"
        }
      }
    },
    "luceneserverDisjunctionMaxQuery": {
      "type": "object",
      "properties": {
        "disjuncts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverQuery"
          }
        },
        "tieBreakerMultiplier": {
          "type": "number",
          "format": "float"
        }
      },
      "description": "A query that generates the union of documents produced by its subqueries, and that scores each document with the\nmaximum score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries."
    },
    "luceneserverDummyResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string"
        }
      }
    },
    "luceneserverExistsQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        }
      },
      "description": "A query that matches documents which contain a value for a field."
    },
    "luceneserverFacet": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "string"
        },
        "paths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "numericRange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNumericRangeType"
          }
        },
        "useOrdsCache": {
          "type": "boolean"
        },
        "labels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "topN": {
          "type": "integer",
          "format": "int32"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        },
        "sampleTopDocs": {
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "luceneserverFacetHierarchyPath": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverFacetResult": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "string"
        },
        "path": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "value": {
          "type": "number",
          "format": "double"
        },
        "labelValues": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverLabelAndValue"
          }
        },
        "childCount": {
          "type": "string",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "luceneserverFacetType": {
      "type": "string",
      "enum": [
        "NO_FACETS",
        "FLAT",
        "HIERARCHY",
        "NUMERIC_RANGE",
        "SORTED_SET_DOC_VALUES"
      ],
      "default": "NO_FACETS",
      "description": "Whether/How this field should index facets, and how."
    },
    "luceneserverFetchTask": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object"
        }
      }
    },
    "luceneserverField": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/luceneserverFieldType"
        },
        "search": {
          "type": "boolean"
        },
        "store": {
          "type": "boolean"
        },
        "storeDocValues": {
          "type": "boolean"
        },
        "sort": {
          "type": "boolean"
        },
        "tokenize": {
          "type": "boolean"
        },
        "group": {
          "type": "boolean"
        },
        "multiValued": {
          "type": "boolean"
        },
        "highlight": {
          "type": "boolean"
        },
        "omitNorms": {
          "type": "boolean"
        },
        "dateTimeFormat": {
          "type": "string"
        },
        "postingsFormat": {
          "type": "string"
        },
        "docValuesFormat": {
          "type": "string"
        },
        "indexOptions": {
          "$ref": "#/definitions/luceneserverIndexOptions"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "title": "TODO make analyzers message types i.e. StandardAnalyzer, EnglishAnalyzer, CustomAnalyzer etc"
        },
        "indexAnalyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "searchAnalyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "termVectors": {
          "$ref": "#/definitions/luceneserverTermVectors"
        },
        "similarity": {
          "type": "string",
          "title": "TODO make similarity message types i.d. DefaultSimilarity, CustomSimilarity, BM25Similarity;"
        },
        "facet": {
          "$ref": "#/definitions/luceneserverFacetType"
        },
        "facetIndexFieldName": {
          "type": "string"
        },
        "additionalProperties": {
          "type": "object"
        },
        "similarityParams": {
          "type": "object"
        },
        "childFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          }
        },
        "eagerGlobalOrdinals": {
          "type": "boolean"
        },
        "nestedDoc": {
          "type": "boolean"
        }
      }
    },
    "luceneserverFieldDefRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "field": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          }
        }
      },
      "title": "Input to registerFields"
    },
    "luceneserverFieldDefResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Response from Server for registerFields"
    },
    "luceneserverFieldType": {
      "type": "string",
      "enum": [
        "ATOM",
        "TEXT",
        "BOOLEAN",
        "LONG",
        "INT",
        "DOUBLE",
        "FLOAT",
        "LAT_LON",
        "DATE_TIME",
        "VIRTUAL",
        "INTERNAL",
        "CUSTOM",
        "_ID",
        "POLYGON",
        "OBJECT"
      ],
      "default": "ATOM",
      "description": "- VIRTUAL: TODO name this \"dynamic\" instead of \"virtual\"?\n - INTERNAL: TODO need tests for internal:",
      "title": "Type of the field"
    },
    "luceneserverFileMetadata": {
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string"
        },
        "len": {
          "type": "string",
          "format": "int64"
        },
        "checksum": {
          "type": "string",
          "format": "int64"
        },
        "headerLength": {
          "type": "integer",
          "format": "int32"
        },
        "header": {
          "type": "string",
          "format": "byte"
        },
        "footerLength": {
          "type": "integer",
          "format": "int32"
        },
        "footer": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "luceneserverFilesMetadata": {
      "type": "object",
      "properties": {
        "numFiles": {
          "type": "integer",
          "format": "int32"
        },
        "fileMetadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFileMetadata"
          }
        }
      }
    },
    "luceneserverForceMergeDeletesRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "doWait": {
          "type": "boolean"
        }
      }
    },
    "luceneserverForceMergeDeletesResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/luceneserverForceMergeDeletesResponseStatus"
        }
      }
    },
    "luceneserverForceMergeDeletesResponseStatus": {
      "type": "string",
      "enum": [
        "FORCE_MERGE_DELETES_COMPLETED",
        "FORCE_MERGE_DELETES_SUBMITTED"
      ],
      "default": "FORCE_MERGE_DELETES_COMPLETED"
    },
    "luceneserverForceMergeRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "maxNumSegments": {
          "type": "integer",
          "format": "int32"
        },
        "doWait": {
          "type": "boolean"
        }
      }
    },
    "luceneserverForceMergeResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/luceneserverForceMergeResponseStatus"
        }
      }
    },
    "luceneserverForceMergeResponseStatus": {
      "type": "string",
      "enum": [
        "FORCE_MERGE_COMPLETED",
        "FORCE_MERGE_SUBMITTED"
      ],
      "default": "FORCE_MERGE_COMPLETED"
    },
    "luceneserverFunctionFilterQuery": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        }
      },
      "title": "A query that retrieves all documents with a positive score calculated by the script"
    },
    "luceneserverFunctionScoreQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        }
      },
      "description": "A query that wraps another query and uses custom scoring logic to compute the wrapped query's score."
    },
    "luceneserverFuzzyInfixSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        },
        "minFuzzyLength": {
          "type": "integer",
          "format": "int32"
        },
        "nonFuzzyPrefix": {
          "type": "integer",
          "format": "int32"
        },
        "maxEdits": {
          "type": "integer",
          "format": "int32"
        },
        "transpositions": {
          "type": "boolean"
        },
        "unicodeAware": {
          "type": "boolean"
        }
      },
      "title": "A suggester that matches fuzzy terms in the input text"
    },
    "luceneserverFuzzyParams": {
      "type": "object",
      "properties": {
        "maxEdits": {
          "type": "integer",
          "format": "int32"
        },
        "prefixLength": {
          "type": "integer",
          "format": "int32"
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32"
        },
        "transpositions": {
          "type": "boolean"
        }
      }
    },
    "luceneserverFuzzySuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        },
        "maxSurfaceFormsPerAnalyzedForm": {
          "type": "integer",
          "format": "int32"
        },
        "maxGraphExpansions": {
          "type": "integer",
          "format": "int32"
        },
        "preserveSep": {
          "type": "boolean"
        },
        "exactFirst": {
          "type": "boolean"
        },
        "minFuzzyLength": {
          "type": "integer",
          "format": "int32"
        },
        "nonFuzzyPrefix": {
          "type": "integer",
          "format": "int32"
        },
        "maxEdits": {
          "type": "integer",
          "format": "int32"
        },
        "transpositions": {
          "type": "boolean"
        },
        "unicodeAware": {
          "type": "boolean"
        }
      },
      "title": "Implements a fuzzy AnalyzingSuggester (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.FuzzySuggester"
    },
    "luceneserverGeoBoundingBoxQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "topLeft": {
          "$ref": "#/definitions/typeLatLng"
        },
        "bottomRight": {
          "$ref": "#/definitions/typeLatLng"
        }
      },
      "description": "A query that matches documents with geopoint within the geo box."
    },
    "luceneserverGeoPointQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "point": {
          "$ref": "#/definitions/typeLatLng"
        }
      },
      "description": "A query that matches documents with polygon that contains the geo point."
    },
    "luceneserverGeoRadiusQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "center": {
          "$ref": "#/definitions/typeLatLng"
        },
        "radius": {
          "type": "string"
        }
      },
      "title": "A query that matches documents with geo point within the radius of target geo point"
    },
    "luceneserverGetAllSnapshotGenResponse": {
      "type": "object",
      "properties": {
        "indexGens": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "luceneserverGetNodesResponse": {
      "type": "object",
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNodeInfo"
          }
        }
      }
    },
    "luceneserverHealthCheckResponse": {
      "type": "object",
      "properties": {
        "health": {
          "$ref": "#/definitions/luceneserverTransferStatusCode"
        }
      }
    },
    "luceneserverIndexOptions": {
      "type": "string",
      "enum": [
        "DOCS_FREQS_POSITIONS",
        "DOCS",
        "DOCS_FREQS",
        "DOCS_FREQS_POSITIONS_OFFSETS"
      ],
      "default": "DOCS_FREQS_POSITIONS",
      "description": "How the tokens should be indexed."
    },
    "luceneserverIndexStatsResponse": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "statsResponse": {
          "$ref": "#/definitions/luceneserverStatsResponse"
        }
      }
    },
    "luceneserverIndicesResponse": {
      "type": "object",
      "properties": {
        "indicesResponse": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverIndexStatsResponse"
          }
        }
      }
    },
    "luceneserverInfixSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        }
      },
      "title": "A suggester that matches terms anywhere in the input text, not just as a prefix. (see @lucene:org:server.InfixSuggester)"
    },
    "luceneserverIntObject": {
      "type": "object",
      "properties": {
        "int": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "Used to be able to check if a value was set"
    },
    "luceneserverLabelAndValue": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "value": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "luceneserverLiveSettingsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "maxRefreshSec": {
          "type": "number",
          "format": "double",
          "description": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen)."
        },
        "minRefreshSec": {
          "type": "number",
          "format": "double",
          "description": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen)."
        },
        "maxSearcherAgeSec": {
          "type": "number",
          "format": "double",
          "description": "Non-current searchers older than this are pruned."
        },
        "indexRamBufferSizeMB": {
          "type": "number",
          "format": "double",
          "description": "Size (in MB) of IndexWriter's RAM buffer."
        },
        "addDocumentsMaxBufferLen": {
          "type": "integer",
          "format": "int32",
          "description": "Max number of documents to add at a time."
        },
        "sliceMaxDocs": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of documents allowed in a parallel search slice."
        },
        "sliceMaxSegments": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of segments allowed in a parallel search slice."
        },
        "virtualShards": {
          "type": "integer",
          "format": "int32",
          "description": "Number of virtual shards to use for this index."
        },
        "maxMergedSegmentMB": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum sized segment to produce during normal merging"
        },
        "segmentsPerTier": {
          "type": "integer",
          "format": "int32",
          "title": "Number of segments per tier used by TieredMergePolicy"
        },
        "defaultSearchTimeoutSec": {
          "type": "number",
          "format": "double",
          "description": "Timeout value to used when not specified in the search request."
        },
        "defaultSearchTimeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "description": "Timeout check every value to use when not specified in the search request."
        },
        "defaultTerminateAfter": {
          "type": "integer",
          "format": "int32",
          "description": "Terminate after value to use when not specified in the search request."
        }
      },
      "title": "Input to liveSettings"
    },
    "luceneserverLiveSettingsResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Response from Server to liveSettings"
    },
    "luceneserverMatchOperator": {
      "type": "string",
      "enum": [
        "SHOULD",
        "MUST"
      ],
      "default": "SHOULD"
    },
    "luceneserverMatchPhraseQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "query": {
          "type": "string"
        },
        "slop": {
          "type": "integer",
          "format": "int32"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        }
      },
      "description": "A query that analyzes the text before finding matching documents. The tokens resulting from the analysis are combined into a PhraseQuery."
    },
    "luceneserverMatchQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "query": {
          "type": "string"
        },
        "operator": {
          "$ref": "#/definitions/luceneserverMatchOperator"
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "fuzzyParams": {
          "$ref": "#/definitions/luceneserverFuzzyParams"
        }
      },
      "description": "A query that analyzes the text before finding matching documents. The tokens resulting from the analysis are combined using term queries in boolean clauses."
    },
    "luceneserverMode": {
      "type": "string",
      "enum": [
        "STANDALONE",
        "PRIMARY",
        "REPLICA"
      ],
      "default": "STANDALONE"
    },
    "luceneserverMultiMatchQuery": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "query": {
          "type": "string"
        },
        "fieldBoosts": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "float"
          }
        },
        "operator": {
          "$ref": "#/definitions/luceneserverMatchOperator"
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "fuzzyParams": {
          "$ref": "#/definitions/luceneserverFuzzyParams"
        },
        "tieBreakerMultiplier": {
          "type": "number",
          "format": "float"
        }
      },
      "description": "A query that creates a match query for each field provided and wraps all the match queries in a disjunction max query."
    },
    "luceneserverNameAndParams": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverNestedQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "path": {
          "type": "string"
        },
        "scoreMode": {
          "$ref": "#/definitions/NestedQueryScoreMode"
        }
      }
    },
    "luceneserverNodeInfo": {
      "type": "object",
      "properties": {
        "hostname": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverNumericRangeType": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "min": {
          "type": "string",
          "format": "int64"
        },
        "minInclusive": {
          "type": "boolean"
        },
        "max": {
          "type": "string",
          "format": "int64"
        },
        "maxInclusive": {
          "type": "boolean"
        }
      }
    },
    "luceneserverOneHighlight": {
      "type": "object",
      "properties": {
        "isHit": {
          "type": "boolean"
        },
        "text": {
          "type": "string"
        }
      }
    },
    "luceneserverOneSuggestLookupResponse": {
      "type": "object",
      "properties": {
        "suggestLookupHighlight": {
          "$ref": "#/definitions/luceneserverSuggestLookupHighlight",
          "title": "Expert: custom Object to hold the result of a highlighted suggestion (currently only works with AnalyzingInfixSuggester)"
        },
        "key": {
          "type": "string",
          "title": "the key's text"
        },
        "weight": {
          "type": "string",
          "format": "int64"
        },
        "payload": {
          "type": "string"
        }
      }
    },
    "luceneserverPhraseQuery": {
      "type": "object",
      "properties": {
        "slop": {
          "type": "integer",
          "format": "int32",
          "description": "Edit distance between respective positions of terms as defined in this PhraseQuery and the positions\nof terms in a document."
        },
        "field": {
          "type": "string"
        },
        "terms": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "A Query that matches documents containing a particular sequence of terms."
    },
    "luceneserverPluginRescorer": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object"
        }
      },
      "title": "Defines an entry point for using a rescorer from plugin"
    },
    "luceneserverPoint": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double"
        },
        "longitude": {
          "type": "number",
          "format": "double"
        }
      },
      "title": "Point representation"
    },
    "luceneserverProfileResult": {
      "type": "object",
      "properties": {
        "searchStats": {
          "$ref": "#/definitions/ProfileResultSearchStats"
        },
        "parsedQuery": {
          "type": "string"
        },
        "rewrittenQuery": {
          "type": "string"
        },
        "drillDownQuery": {
          "type": "string"
        }
      },
      "title": "Defines detailed profiling stats for queries that set profile=true"
    },
    "luceneserverQuery": {
      "type": "object",
      "properties": {
        "queryType": {
          "$ref": "#/definitions/luceneserverQueryType"
        },
        "boost": {
          "type": "number",
          "format": "float"
        },
        "booleanQuery": {
          "$ref": "#/definitions/luceneserverBooleanQuery"
        },
        "phraseQuery": {
          "$ref": "#/definitions/luceneserverPhraseQuery"
        },
        "functionScoreQuery": {
          "$ref": "#/definitions/luceneserverFunctionScoreQuery"
        },
        "termQuery": {
          "$ref": "#/definitions/luceneserverTermQuery"
        },
        "termInSetQuery": {
          "$ref": "#/definitions/luceneserverTermInSetQuery"
        },
        "disjunctionMaxQuery": {
          "$ref": "#/definitions/luceneserverDisjunctionMaxQuery"
        },
        "matchQuery": {
          "$ref": "#/definitions/luceneserverMatchQuery"
        },
        "matchPhraseQuery": {
          "$ref": "#/definitions/luceneserverMatchPhraseQuery"
        },
        "multiMatchQuery": {
          "$ref": "#/definitions/luceneserverMultiMatchQuery"
        },
        "rangeQuery": {
          "$ref": "#/definitions/luceneserverRangeQuery"
        },
        "geoBoundingBoxQuery": {
          "$ref": "#/definitions/luceneserverGeoBoundingBoxQuery"
        },
        "geoPointQuery": {
          "$ref": "#/definitions/luceneserverGeoPointQuery"
        },
        "nestedQuery": {
          "$ref": "#/definitions/luceneserverNestedQuery"
        },
        "existsQuery": {
          "$ref": "#/definitions/luceneserverExistsQuery"
        },
        "geoRadiusQuery": {
          "$ref": "#/definitions/luceneserverGeoRadiusQuery"
        },
        "functionFilterQuery": {
          "$ref": "#/definitions/luceneserverFunctionFilterQuery"
        }
      },
      "description": "Defines a full query consisting of a QueryNode which may be one of several types."
    },
    "luceneserverQueryRescorer": {
      "type": "object",
      "properties": {
        "rescoreQuery": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "queryWeight": {
          "type": "number",
          "format": "double"
        },
        "rescoreQueryWeight": {
          "type": "number",
          "format": "double"
        }
      },
      "title": "Defines a rescorer which uses query to rescore documents in the second pass"
    },
    "luceneserverQuerySortField": {
      "type": "object",
      "properties": {
        "doDocScores": {
          "type": "boolean"
        },
        "doMaxScore": {
          "type": "boolean"
        },
        "fields": {
          "$ref": "#/definitions/luceneserverSortFields"
        }
      }
    },
    "luceneserverQueryType": {
      "type": "string",
      "enum": [
        "NONE",
        "BOOLEAN_QUERY",
        "PHRASE_QUERY",
        "FUNCTION_SCORE_QUERY",
        "TERM_QUERY",
        "TERM_IN_SET_QUERY",
        "DISJUNCTION_MAX",
        "MATCH",
        "MATCH_PHRASE",
        "MULTI_MATCH",
        "RANGE",
        "GEO_BOUNDING_BOX",
        "GEO_POINT",
        "NESTED",
        "EXISTS",
        "GEO_RADIUS"
      ],
      "default": "NONE",
      "description": "Defines different types of QueryNodes."
    },
    "luceneserverRangeQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "lower": {
          "type": "string"
        },
        "upper": {
          "type": "string"
        },
        "lowerExclusive": {
          "type": "boolean"
        },
        "upperExclusive": {
          "type": "boolean"
        }
      },
      "description": "A query that matches documents with values within the specified range. The lower and upper values though provided as strings will be converted to the type of the field. This works with INT, LONG, FLOAT, DOUBLE and DATE_TIME field types."
    },
    "luceneserverRawFileChunk": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string",
          "format": "byte"
        },
        "seqNum": {
          "type": "integer",
          "format": "int32",
          "title": "sequence number for this chunk, only used for acked file copy"
        },
        "ack": {
          "type": "boolean",
          "title": "if this chunk should be acked, only used for acked file copy"
        }
      }
    },
    "luceneserverRefreshRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverRefreshResponse": {
      "type": "object",
      "properties": {
        "refreshTimeMS": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "luceneserverReleaseSnapshotRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "snapshotId": {
          "$ref": "#/definitions/luceneserverSnapshotId"
        }
      }
    },
    "luceneserverReleaseSnapshotResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        }
      }
    },
    "luceneserverRescorer": {
      "type": "object",
      "properties": {
        "windowSize": {
          "type": "integer",
          "format": "int32"
        },
        "queryRescorer": {
          "$ref": "#/definitions/luceneserverQueryRescorer"
        },
        "pluginRescorer": {
          "$ref": "#/definitions/luceneserverPluginRescorer"
        },
        "name": {
          "type": "string",
          "title": "Must be unique for each Rescorer"
        }
      },
      "title": "Defines a rescorer which is executed after the first search pass"
    },
    "luceneserverRestoreIndex": {
      "type": "object",
      "properties": {
        "serviceName": {
          "type": "string"
        },
        "resourceName": {
          "type": "string"
        },
        "deleteExistingData": {
          "type": "boolean"
        }
      }
    },
    "luceneserverScript": {
      "type": "object",
      "properties": {
        "lang": {
          "type": "string"
        },
        "source": {
          "type": "string"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ScriptParamValue"
          }
        }
      }
    },
    "luceneserverSearchRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "startHit": {
          "type": "integer",
          "format": "int32"
        },
        "topHits": {
          "type": "integer",
          "format": "int32"
        },
        "timeoutSec": {
          "type": "number",
          "format": "double",
          "description": "Maximum number of seconds spent on each collection phase; note that for\nmulti-pass searches (e.g. query-time grouping), this timeout applies to each phase."
        },
        "retrieveFields": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "queryText": {
          "type": "string"
        },
        "virtualFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverVirtualField"
          }
        },
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "querySort": {
          "$ref": "#/definitions/luceneserverQuerySortField"
        },
        "indexGen": {
          "type": "string",
          "format": "int64"
        },
        "version": {
          "type": "string",
          "format": "int64"
        },
        "snapshot": {
          "type": "string"
        },
        "totalHitsThreshold": {
          "type": "integer",
          "format": "int32"
        },
        "facets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacet"
          }
        },
        "fetchTasks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFetchTask"
          }
        },
        "disallowPartialResults": {
          "type": "boolean"
        },
        "queryNestedPath": {
          "type": "string"
        },
        "rescorers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverRescorer"
          }
        },
        "profile": {
          "type": "boolean",
          "title": "If detailed request execution profiling should be included in the response"
        },
        "timeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "description": "Check the search timeout condition after each collection of n documents in a segment. If 0, timeout is only checked on the segment boundary."
        },
        "collectors": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollector"
          },
          "description": "Additional document collectors. Provides support for operations such as aggregation."
        },
        "terminateAfter": {
          "type": "integer",
          "format": "int32",
          "description": "Stop document collection in search phase after this many documents, 0 for unlimited."
        }
      }
    },
    "luceneserverSearchResponse": {
      "type": "object",
      "properties": {
        "diagnostics": {
          "$ref": "#/definitions/SearchResponseDiagnostics"
        },
        "hitTimeout": {
          "type": "boolean"
        },
        "totalHits": {
          "$ref": "#/definitions/luceneserverTotalHits"
        },
        "hits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchResponseHit"
          }
        },
        "searchState": {
          "$ref": "#/definitions/SearchResponseSearchState"
        },
        "facetResult": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacetResult"
          }
        },
        "profileResult": {
          "$ref": "#/definitions/luceneserverProfileResult",
          "title": "Detailed stats returned when profile=true in request"
        },
        "collectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "title": "Results from any additional document collectors"
        },
        "terminatedEarly": {
          "type": "boolean",
          "title": "If this query hit the terminateAfter threshold specified in the request"
        }
      }
    },
    "luceneserverSearcher": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "the version recorded in the commit that the reader opened.\nThis version is advanced every time a change is made with IndexWriter."
        },
        "numDocs": {
          "type": "integer",
          "format": "int32"
        },
        "segments": {
          "type": "string"
        },
        "staleAgeSeconds": {
          "type": "number",
          "format": "double"
        },
        "numSegments": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverSearcherVersion": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64"
        },
        "didRefresh": {
          "type": "boolean"
        }
      }
    },
    "luceneserverSelector": {
      "type": "string",
      "enum": [
        "MIN",
        "MAX",
        "MIDDLE_MIN",
        "MIDDLE_MAX"
      ],
      "default": "MIN",
      "title": "For multi valued fields, how to select which value is used for sorting"
    },
    "luceneserverSettingsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "mergeMaxMBPerSec": {
          "type": "number",
          "format": "double"
        },
        "nrtCachingDirectoryMaxMergeSizeMB": {
          "type": "number",
          "format": "double"
        },
        "nrtCachingDirectoryMaxSizeMB": {
          "type": "number",
          "format": "double"
        },
        "concurrentMergeSchedulerMaxThreadCount": {
          "type": "integer",
          "format": "int32"
        },
        "concurrentMergeSchedulerMaxMergeCount": {
          "type": "integer",
          "format": "int32"
        },
        "indexSort": {
          "$ref": "#/definitions/luceneserverSortFields"
        },
        "indexVerbose": {
          "type": "boolean"
        },
        "indexMergeSchedulerAutoThrottle": {
          "type": "boolean"
        },
        "normsFormat": {
          "type": "string"
        },
        "directory": {
          "type": "string",
          "title": "Base Directory implementation to use (NRTCachingDirectory will wrap this) either one of the core implementations (FSDirectory, MMapDirectory, NIOFSDirectory, SimpleFSDirectory, RAMDirectory (for temporary indices!) or a fully qualified path to a Directory implementation that has a public constructor taking a single File argument default: FSDirectory"
        }
      },
      "title": "Input to settings"
    },
    "luceneserverSettingsResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Settings Response returned from Server"
    },
    "luceneserverSnapshotId": {
      "type": "object",
      "properties": {
        "indexGen": {
          "type": "string",
          "format": "int64"
        },
        "taxonomyGen": {
          "type": "string",
          "format": "int64"
        },
        "stateGen": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "luceneserverSortFields": {
      "type": "object",
      "properties": {
        "sortedFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSortType"
          }
        }
      },
      "title": "Fields to sort on either during index time or search time"
    },
    "luceneserverSortType": {
      "type": "object",
      "properties": {
        "fieldName": {
          "type": "string"
        },
        "selector": {
          "$ref": "#/definitions/luceneserverSelector"
        },
        "origin": {
          "$ref": "#/definitions/luceneserverPoint"
        },
        "missingLat": {
          "type": "boolean",
          "description": "Whether missing values should sort last instead of first.\nNote that this runs \\\"before\\\" reverse, so if you sort missing first and reverse=true then missing values will\nbe at the end."
        },
        "reverse": {
          "type": "boolean",
          "title": "Sort in reverse of the field's natural order"
        }
      },
      "description": "\"The field to sort on. Pass \u003ccode\u003edocid\u003c/code\u003e for index order and \u003ccode\u003escore\u003c/code\u003e for relevance sort."
    },
    "luceneserverStartIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/luceneserverMode"
        },
        "primaryGen": {
          "type": "string",
          "format": "int64"
        },
        "primaryAddress": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        },
        "restore": {
          "$ref": "#/definitions/luceneserverRestoreIndex"
        }
      },
      "title": "Start the index"
    },
    "luceneserverStartIndexResponse": {
      "type": "object",
      "properties": {
        "maxDoc": {
          "type": "integer",
          "format": "int32"
        },
        "numDocs": {
          "type": "integer",
          "format": "int32"
        },
        "segments": {
          "type": "string"
        },
        "startTimeMS": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "luceneserverStateRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverStateResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      }
    },
    "luceneserverStatsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverStatsResponse": {
      "type": "object",
      "properties": {
        "ord": {
          "type": "integer",
          "format": "int32"
        },
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "description": "The total number of docs in this index, including docs not yet flushed (still in the RAM buffer),\nnot counting deletions."
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "description": "*\nThe total number of docs in this index, including\ndocs not yet flushed (still in the RAM buffer), and\nincluding deletions. NOTE: buffered deletions\nare not counted.  If you really need these to be\ncounted you should call {@link IndexWriter#commit()} first."
        },
        "dirSize": {
          "type": "string",
          "format": "int64"
        },
        "state": {
          "type": "string"
        },
        "taxonomy": {
          "$ref": "#/definitions/luceneserverTaxonomy"
        },
        "searchers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSearcher"
          }
        },
        "currentSearcher": {
          "$ref": "#/definitions/luceneserverSearcher"
        }
      }
    },
    "luceneserverStopIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverSuggestLocalSource": {
      "type": "object",
      "properties": {
        "localFile": {
          "type": "string",
          "description": "Local file (to the server) to read suggestions + weights from; format is weight U+001F suggestion U+001F payload,\none per line, with suggestion UTF-8 encoded. If this option is used then searcher, suggestField,\nweightField/Expression, payloadField should not be specified."
        },
        "hasContexts": {
          "type": "boolean"
        },
        "hasPayload": {
          "type": "boolean"
        },
        "hasMultiSearchText": {
          "type": "boolean"
        }
      }
    },
    "luceneserverSuggestLookupHighlight": {
      "type": "object",
      "properties": {
        "oneHighlight": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverOneHighlight"
          }
        }
      }
    },
    "luceneserverSuggestLookupRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "suggestName": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "highlight": {
          "type": "boolean"
        },
        "allTermsRequired": {
          "type": "boolean"
        },
        "contexts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverSuggestLookupResponse": {
      "type": "object",
      "properties": {
        "results": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverOneSuggestLookupResponse"
          }
        }
      }
    },
    "luceneserverSuggestNonLocalSource": {
      "type": "object",
      "properties": {
        "indexGen": {
          "type": "string",
          "format": "int64"
        },
        "version": {
          "type": "string",
          "format": "int64"
        },
        "snapshot": {
          "type": "string"
        },
        "suggestField": {
          "type": "string"
        },
        "weightField": {
          "type": "string"
        },
        "weightExpression": {
          "type": "string"
        },
        "payloadField": {
          "type": "string"
        },
        "contextField": {
          "type": "string"
        },
        "searchTextField": {
          "type": "string"
        }
      }
    },
    "luceneserverTaxonomy": {
      "type": "object",
      "properties": {
        "numOrds": {
          "type": "integer",
          "format": "int32"
        },
        "segments": {
          "type": "string"
        }
      }
    },
    "luceneserverTermInSetQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Field in the document to query."
        },
        "textTerms": {
          "$ref": "#/definitions/TermInSetQueryTextTerms",
          "description": "Text terms to search for."
        },
        "intTerms": {
          "$ref": "#/definitions/TermInSetQueryIntTerms",
          "description": "Int terms to search for."
        },
        "longTerms": {
          "$ref": "#/definitions/TermInSetQueryLongTerms",
          "description": "Long terms to search for."
        },
        "floatTerms": {
          "$ref": "#/definitions/TermInSetQueryFloatTerms",
          "description": "Float terms to search for."
        },
        "doubleTerms": {
          "$ref": "#/definitions/TermInSetQueryDoubleTerms",
          "description": "Double terms to search for."
        }
      },
      "description": "Specialization for a disjunction over many terms that behaves like a ConstantScoreQuery over a BooleanQuery containing only BooleanClause.Occur.SHOULD clauses. Only ONE of the types of terms needs to be provided - the one that matches the type of the field."
    },
    "luceneserverTermQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Field in the document to query."
        },
        "textValue": {
          "type": "string",
          "description": "TEXT FieldType term to search for."
        },
        "intValue": {
          "type": "integer",
          "format": "int32",
          "description": "INT FieldType term to search for."
        },
        "longValue": {
          "type": "string",
          "format": "int64",
          "description": "LONG FieldType term to search for."
        },
        "floatValue": {
          "type": "number",
          "format": "float",
          "description": "FLOAT FieldType term to search for."
        },
        "doubleValue": {
          "type": "number",
          "format": "double",
          "description": "DOUBLE FieldType term to search for."
        },
        "booleanValue": {
          "type": "boolean",
          "description": "BOOLEAN FieldType term to search for."
        }
      },
      "description": "A query that matches documents containing a term."
    },
    "luceneserverTermVectors": {
      "type": "string",
      "enum": [
        "NO_TERMVECTORS",
        "TERMS",
        "TERMS_POSITIONS",
        "TERMS_POSITIONS_OFFSETS",
        "TERMS_POSITIONS_OFFSETS_PAYLOADS"
      ],
      "default": "NO_TERMVECTORS",
      "description": "Whether/how term vectors should be indexed."
    },
    "luceneserverTermsCollector": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Placeholder: TODO implement"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "description": "Use FacetScript definition to produce terms."
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of top terms to return."
        }
      },
      "description": "Definition of term aggregating collector."
    },
    "luceneserverTotalHits": {
      "type": "object",
      "properties": {
        "relation": {
          "$ref": "#/definitions/TotalHitsRelation"
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "* The value of the total hit count. Must be interpreted in the context of * {#relation}."
        }
      }
    },
    "luceneserverTransferStatus": {
      "type": "object",
      "properties": {
        "Message": {
          "type": "string"
        },
        "Code": {
          "$ref": "#/definitions/luceneserverTransferStatusCode"
        }
      }
    },
    "luceneserverTransferStatusCode": {
      "type": "string",
      "enum": [
        "Unknown",
        "Done",
        "Failed",
        "Ongoing"
      ],
      "default": "Unknown"
    },
    "luceneserverVirtualField": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        },
        "name": {
          "type": "string"
        }
      },
      "title": "Virtual field used during search"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\n The JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    },
    "runtimeError": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "runtimeStreamError": {
      "type": "object",
      "properties": {
        "grpc_code": {
          "type": "integer",
          "format": "int32"
        },
        "http_code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "http_status": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "typeLatLng": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double",
          "description": "The latitude in degrees. It must be in the range [-90.0, +90.0]."
        },
        "longitude": {
          "type": "number",
          "format": "double",
          "description": "The longitude in degrees. It must be in the range [-180.0, +180.0]."
        }
      },
      "description": "An object representing a latitude/longitude pair. This is expressed as a pair\nof doubles representing degrees latitude and degrees longitude. Unless\nspecified otherwise, this must conform to the\n\u003ca href=\"http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf\"\u003eWGS84\nstandard\u003c/a\u003e. Values must be within normalized ranges."
    }
  }
}
