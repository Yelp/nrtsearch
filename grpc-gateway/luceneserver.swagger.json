{
  "swagger": "2.0",
  "info": {
    "title": "yelp/nrtsearch/luceneserver.proto",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/status/metrics": {
      "get": {
        "summary": "metrics",
        "operationId": "LuceneServer_metrics",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/add_documents": {
      "post": {
        "summary": "Adds a stream of Documents",
        "operationId": "LuceneServer_addDocuments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": " (streaming inputs)",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/backup_index": {
      "post": {
        "summary": "backs up a resource (index) and it associated metadata e.g. settings, schema to s3",
        "operationId": "LuceneServer_backupIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBackupIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBackupIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/backup_warming_queries": {
      "post": {
        "summary": "Backup warming queries to S3",
        "operationId": "LuceneServer_backupWarmingQueries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBackupWarmingQueriesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBackupWarmingQueriesRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/commit": {
      "post": {
        "summary": "Commits all pending changes to durable storage",
        "operationId": "LuceneServer_commit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCommitResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCommitRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/create_index": {
      "post": {
        "summary": "Create an Index",
        "operationId": "LuceneServer_createIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCreateIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCreateIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/create_snapshot": {
      "post": {
        "summary": "Creates a snapshot in the index, which is saved point-in-time view of the last commit\nin the index such that no files referenced by that snapshot will be deleted by ongoing\nindexing until the snapshot is released with @releaseSnapshot.  Note that this will\nreference the last commit, so be sure to call commit first if you have pending changes\nthat you'd like to be included in the snapshot.\nThis can be used for backup purposes, i.e. after creating the snapshot you can copy\nall referenced files to backup storage, and then release the snapshot once complete.\nTo restore the backup, just copy all the files back and restart the server.\nIt can also be used for transactional purposes, i.e. if you sometimes need to search a\nspecific snapshot instead of the current live index. Creating a snapshot is very fast\n(does not require any file copying), but over time it will consume extra disk space as\nold segments are merged in the index.  Be sure to release the snapshot once you're done.\nSnapshots survive shutdown and restart of the server.  Returns all protected filenames\nreferenced by this snapshot: these files will not change and will not be deleted until\nthe snapshot is released.  This returns the directories and files referenced by the snapshot.",
        "operationId": "LuceneServer_createSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCreateSnapshotResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCreateSnapshotRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/custom/{id}/{path}": {
      "post": {
        "summary": "Process request in a plugin which implements CustomRequestPlugin interface.",
        "operationId": "LuceneServer_custom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCustomResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCustomRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete": {
      "post": {
        "summary": "Delete documents",
        "operationId": "LuceneServer_delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_all": {
      "post": {
        "summary": "Delete all documents for index",
        "operationId": "LuceneServer_deleteAll",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteAllDocumentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteAllDocumentsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_by_query": {
      "post": {
        "summary": "Delete documents matching a query",
        "operationId": "LuceneServer_deleteByQuery",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteByQueryRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_index": {
      "post": {
        "summary": "Delete index",
        "operationId": "LuceneServer_deleteIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_index_backup": {
      "post": {
        "operationId": "LuceneServer_deleteIndexBackup",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexBackupResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexBackupRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/force_merge": {
      "post": {
        "summary": "Forces merge policy to merge segments until there are \u003c= maxNumSegments. The actual\nmerges to be executed are determined by the MergePolicy. This call will merge those\nsegments present in the index when the call started. If other threads are still\nadding documents and flushing segments, those newly created segments will not be\nmerged unless you call forceMerge again.",
        "operationId": "LuceneServer_forceMerge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/force_merge_deletes": {
      "post": {
        "summary": "Forces merging of all segments that have deleted documents. The actual merges to be\nexecuted are determined by the MergePolicy. For example, the default TieredMergePolicy\nwill only pick a segment if the percentage of deleted docs is over 10%.\nThis method first flushes a new segment (if there are indexed documents), and applies\nall buffered deletes.",
        "operationId": "LuceneServer_forceMergeDeletes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeDeletesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeDeletesRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/get_all_snapshot_index_gen/{indexName}": {
      "get": {
        "summary": "Gets all unreleased index gens of snapshots previously created with @createSnapshot.",
        "operationId": "LuceneServer_getAllSnapshotIndexGen",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverGetAllSnapshotGenResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/indices": {
      "get": {
        "summary": "indices",
        "operationId": "LuceneServer_indices",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverIndicesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/live_settings": {
      "post": {
        "summary": "Change global offline or online settings for this index.",
        "operationId": "LuceneServer_liveSettings",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/ready": {
      "get": {
        "summary": "Checks if a node is ready to receive traffic by checking if all the indices (which can be preloaded)\nare started. Can specify comma-separated list of index name to only check specific indices if needed.",
        "operationId": "LuceneServer_ready",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexNames",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/ready/{indexNames}": {
      "get": {
        "summary": "Checks if a node is ready to receive traffic by checking if all the indices (which can be preloaded)\nare started. Can specify comma-separated list of index name to only check specific indices if needed.",
        "operationId": "LuceneServer_ready2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexNames",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/refresh": {
      "post": {
        "summary": "Refresh the latest searcher for an index",
        "operationId": "LuceneServer_refresh",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverRefreshResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverRefreshRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/register_fields": {
      "post": {
        "summary": "Registers one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).\nPass a list of Fields and an indexName. Any number of fields may be registered in a single request,\nand once a field is registered it cannot be changed (write-once).\nThis returns the full set of fields currently registered.",
        "operationId": "LuceneServer_registerFields",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/release_snapshot": {
      "post": {
        "summary": "releases a snapshot previously created with @createSnapshot.",
        "operationId": "LuceneServer_releaseSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverReleaseSnapshotResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverReleaseSnapshotRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/reload_state": {
      "post": {
        "summary": "Reload state from the backend",
        "operationId": "LuceneServer_reloadState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverReloadStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverReloadStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/search": {
      "post": {
        "summary": "Search",
        "operationId": "LuceneServer_search",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSearchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSearchRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/settings": {
      "post": {
        "summary": "Change global offline settings for this index.\nThis returns the currently set settings; pass no settings changes to retrieve current settings.",
        "operationId": "LuceneServer_settings",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/start_index": {
      "post": {
        "summary": "Starts an index",
        "operationId": "LuceneServer_startIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/state": {
      "post": {
        "summary": "Gets the state of a started index, includes settings, live_settings, search schema, suggest schema",
        "operationId": "LuceneServer_state",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/state/{indexName}": {
      "get": {
        "summary": "Gets the state of a started index, includes settings, live_settings, search schema, suggest schema",
        "operationId": "LuceneServer_state2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stats": {
      "post": {
        "summary": "Retrieve index statistics",
        "operationId": "LuceneServer_stats",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStatsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStatsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stats/{indexName}": {
      "get": {
        "summary": "Retrieve index statistics",
        "operationId": "LuceneServer_stats2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStatsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/status": {
      "get": {
        "summary": "healthcheck",
        "operationId": "LuceneServer_status",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "check",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stop_index": {
      "post": {
        "summary": "Stops an index",
        "operationId": "LuceneServer_stopIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDummyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStopIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/suggest_build": {
      "post": {
        "summary": "Builds a new auto-suggester, loading suggestions via the provided local file path.",
        "operationId": "LuceneServer_buildSuggest",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/suggest_lookup": {
      "post": {
        "summary": "Perform an auto-suggest lookup.",
        "operationId": "LuceneServer_suggestLookup",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSuggestLookupResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSuggestLookupRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/suggest_update": {
      "post": {
        "summary": "Updates existing suggestions, if the suggester supports near-real-time changes.",
        "operationId": "LuceneServer_updateSuggest",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBuildSuggestRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/update_fields": {
      "post": {
        "summary": "Adds one or more fields.  Fields must be registered before they can be added in a document (via @addDocument).\nPass a list of Fields and an indexName. Any number of fields may be registered in a single request,\nand once a field is registered it cannot be changed (write-once).\nThis returns the full set of fields currently registered.",
        "operationId": "LuceneServer_updateFields",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/live_settings": {
      "post": {
        "summary": "Change global offline or online settings for this index.",
        "operationId": "LuceneServer_liveSettingsV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsV2Request"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/live_settings/{indexName}": {
      "get": {
        "summary": "Change global offline or online settings for this index.",
        "operationId": "LuceneServer_liveSettingsV22",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Index name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "liveSettings.maxRefreshSec",
            "description": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen), default: 1.0.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.minRefreshSec",
            "description": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen), default: 0.05.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.maxSearcherAgeSec",
            "description": "Non-current searchers older than this are pruned, default: 60.0.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.indexRamBufferSizeMB",
            "description": "Size (in MB) of IndexWriter's RAM buffer, default: 16.0.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.addDocumentsMaxBufferLen",
            "description": "Max number of documents to add at a time, default: 100.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.sliceMaxDocs",
            "description": "Maximum number of documents allowed in a parallel search slice, default: 250,000.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.sliceMaxSegments",
            "description": "Maximum number of segments allowed in a parallel search slice, default: 5.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.virtualShards",
            "description": "Number of virtual shards to use for this index, default: 1.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.maxMergedSegmentMB",
            "description": "Maximum sized segment to produce during normal merging, default: 5GB.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.segmentsPerTier",
            "description": "Number of segments per tier used by TieredMergePolicy, default: 10.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.defaultSearchTimeoutSec",
            "description": "Timeout value to used when not specified in the search request, or 0 for no timeout, default: 0.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.defaultSearchTimeoutCheckEvery",
            "description": "Timeout check every value to use when not specified in the search request, or 0 for none, default: 0.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.defaultTerminateAfter",
            "description": "Terminate after value to use when not specified in the search request, or 0 for none, default: 0.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.maxMergePreCopyDurationSec",
            "description": "Merge precopy would be stopped after this time, or 0 for no checks, default: 0.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "liveSettings.verboseMetrics",
            "description": "Collect and publish additional index metrics, which may be more expensive in terms of volume, memory and/or compute, default: false.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "local",
            "description": "When set to true, live settings changes are only applied to the local node. These changes are ephemeral, so will not persist through a restart. Also, the live settings returned in the response will contain the local overrides only when this flag is true.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/search": {
      "post": {
        "summary": "Search V2",
        "operationId": "LuceneServer_searchV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protobufAny"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSearchRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/settings": {
      "post": {
        "summary": "Change global offline settings for this index.\nThis returns the currently set settings; pass no settings to retrieve current settings.",
        "operationId": "LuceneServer_settingsV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsV2Request"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/settings/{indexName}": {
      "get": {
        "summary": "Change global offline settings for this index.\nThis returns the currently set settings; pass no settings to retrieve current settings.",
        "operationId": "LuceneServer_settingsV22",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Index name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "settings.nrtCachingDirectoryMaxMergeSizeMB",
            "description": "Largest merged segment size to cache in RAMDirectory, default: 5.0MB.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "settings.nrtCachingDirectoryMaxSizeMB",
            "description": "Largest overall size for all files cached in NRTCachingDirectory, default: 60.0MB.",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "settings.concurrentMergeSchedulerMaxThreadCount",
            "description": "How many merge threads to allow at once.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "settings.concurrentMergeSchedulerMaxMergeCount",
            "description": "Maximum backlog of pending merges before indexing threads are stalled.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "settings.indexMergeSchedulerAutoThrottle",
            "description": "Turn on/off the merge scheduler's auto throttling, default: off.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "settings.directory",
            "description": "Base Directory implementation to use (NRTCachingDirectory will wrap this) either one of the core implementations (FSDirectory, MMapDirectory, NIOFSDirectory, SimpleFSDirectory, RAMDirectory (for temporary indices!) or a fully qualified path to a Directory implementation that has a public constructor taking a single File argument default: FSDirectory.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/start_index": {
      "post": {
        "summary": "Starts an index using configuration in IndexStartConfig",
        "operationId": "LuceneServer_startIndexV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexV2Request"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    }
  },
  "definitions": {
    "AddDocumentRequestMultiValuedField": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "faceHierarchyPaths": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacetHierarchyPath"
          },
          "title": "Facet paths/hierarchy to bucket these values by, if indexed field is of type Facet.HIERARCHY"
        }
      },
      "description": "we use this wrapper object to represent each field as a multivalued field."
    },
    "BooleanClauseOccur": {
      "type": "string",
      "enum": [
        "SHOULD",
        "MUST",
        "FILTER",
        "MUST_NOT"
      ],
      "default": "SHOULD",
      "description": "Defines how clauses may occur in matching documents. This will always be SHOULD by default."
    },
    "BucketOrderOrderType": {
      "type": "string",
      "enum": [
        "DESC",
        "ASC"
      ],
      "default": "DESC",
      "title": "Sorting order type"
    },
    "BucketResultBucket": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "count": {
          "type": "integer",
          "format": "int32"
        },
        "nestedCollectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "description": "Nested collector results for sub-aggregations of this bucket."
        }
      }
    },
    "FieldValueVector": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      }
    },
    "HighlightSettings": {
      "type": "object",
      "properties": {
        "highlighter_type": {
          "$ref": "#/definitions/luceneserverHighlightType",
          "description": "Specify type of highlighter to use. Ignored right now in nrtsearch."
        },
        "pre_tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Used along with post_tags to specify how to wrap the highlighted text."
        },
        "post_tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Used along with pre_tags to specify how to wrap the highlighted text."
        },
        "fragment_size": {
          "type": "integer",
          "format": "int64",
          "description": "Number of characters in highlighted fragment, 100 by default. Set it to be 0 to fetch the entire field."
        },
        "max_number_of_fragments": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum number of highlight fragments to return, 5 by default. If set to 0 returns entire text as a single fragment ignoring fragment_size."
        },
        "highlight_query": {
          "$ref": "#/definitions/luceneserverQuery",
          "description": "Specify a query here if highlighting is desired against a different query than the search query."
        },
        "field_match": {
          "type": "boolean",
          "description": "Set to true to highlight fields only if specified in the search query."
        },
        "score_ordered": {
          "type": "boolean",
          "title": "Sorts highlighted fragments by score when set to true. By default, fragments will be output in the order they appear in the field. (Default is true)"
        },
        "fragmenter": {
          "type": "string",
          "description": "Select Fragmenter between span (default) and simple. This is only applicable for plain highlighters."
        },
        "discrete_multivalue": {
          "type": "boolean",
          "title": "Let the fragment builder respect the multivalue fields. Each fragment won't cross multiple value fields if set true. (Default is false)"
        },
        "custom_highlighter_name": {
          "type": "string",
          "description": "When highlighter_type is CUSTOM, use this string identifier to specify the highlighter. It is ignored for any other highlighter_types."
        },
        "custom_highlighter_params": {
          "type": "object",
          "description": "Optional Custom parameters for custom highlighters. If a field overriding is present, the global setting will be omitted for this field, and no merge will happen."
        },
        "boundary_scanner": {
          "type": "string",
          "description": "Define the boundary decision when creating fragments. Options are \"simple\" (default in fast vector highlighter), \"word\" or \"sentence\"."
        },
        "boundary_chars": {
          "type": "string",
          "description": "Terminating chars when using \"simple\" boundary_scanner. The default is \".,!? \\t\\n\"."
        },
        "boundary_max_scan": {
          "type": "integer",
          "format": "int64",
          "description": "Number of chars to scan before finding the boundary_chars if using \"simple\" boundary scanner; If \"boundary_chars\" is not found after max scan, fragments will start/end at the original place. Default is 20."
        },
        "boundary_scanner_locale": {
          "type": "string",
          "description": "Locale used in boundary scanner when using \"word\" or \"sentence\" boundary_scanner. Examples: \"en-US\", \"ch-ZH\"."
        }
      }
    },
    "HitCompositeFieldValue": {
      "type": "object",
      "properties": {
        "fieldValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HitFieldValue"
          }
        }
      }
    },
    "HitFieldValue": {
      "type": "object",
      "properties": {
        "textValue": {
          "type": "string"
        },
        "booleanValue": {
          "type": "boolean"
        },
        "intValue": {
          "type": "integer",
          "format": "int32"
        },
        "longValue": {
          "type": "string",
          "format": "int64"
        },
        "floatValue": {
          "type": "number",
          "format": "float"
        },
        "doubleValue": {
          "type": "number",
          "format": "double"
        },
        "latLngValue": {
          "$ref": "#/definitions/typeLatLng"
        },
        "structValue": {
          "type": "object"
        },
        "vectorValue": {
          "$ref": "#/definitions/FieldValueVector",
          "title": "Value for VECTOR FieldType"
        }
      }
    },
    "HitHighlights": {
      "type": "object",
      "properties": {
        "fragments": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Highlighted text fragments"
        }
      }
    },
    "MultiFunctionScoreQueryBoostMode": {
      "type": "string",
      "enum": [
        "BOOST_MODE_MULTIPLY",
        "BOOST_MODE_SUM",
        "BOOST_MODE_REPLACE"
      ],
      "default": "BOOST_MODE_MULTIPLY",
      "description": "- BOOST_MODE_MULTIPLY: Multiply scores together\n - BOOST_MODE_SUM: Add scores together\n - BOOST_MODE_REPLACE: Ignore the query score, and use the function score only",
      "title": "How to combine final function score with query score"
    },
    "MultiFunctionScoreQueryFilterFunction": {
      "type": "object",
      "properties": {
        "filter": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Apply function only to docs that pass this filter, match all if not specified"
        },
        "weight": {
          "type": "number",
          "format": "float",
          "title": "Weight to multiply with function score, 1.0 if not specified"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Produce score with score script definition"
        }
      },
      "title": "Function to produce a weighted value"
    },
    "MultiFunctionScoreQueryFunctionScoreMode": {
      "type": "string",
      "enum": [
        "SCORE_MODE_MULTIPLY",
        "SCORE_MODE_SUM"
      ],
      "default": "SCORE_MODE_MULTIPLY",
      "description": "- SCORE_MODE_MULTIPLY: Multiply weighted function scores together\n - SCORE_MODE_SUM: Add weighted function scores together",
      "title": "How to combine multiple function scores to produce a final function score"
    },
    "MultiMatchQueryMatchType": {
      "type": "string",
      "enum": [
        "BEST_FIELDS",
        "PHRASE_PREFIX",
        "CROSS_FIELDS"
      ],
      "default": "BEST_FIELDS",
      "description": "Type defining the execution behavior of the match.\n\n - BEST_FIELDS: Finds documents which match any field, but uses the _score from the best field.\n - PHRASE_PREFIX: Runs a MatchPhrasePrefixQuery query on each field and uses the _score from the best field.\n - CROSS_FIELDS: Finds documents that match across multiple fields, as if they were a single field."
    },
    "NestedQueryScoreMode": {
      "type": "string",
      "enum": [
        "NONE",
        "AVG",
        "MAX",
        "MIN",
        "SUM"
      ],
      "default": "NONE"
    },
    "ProfileResultAdditionalCollectorStats": {
      "type": "object",
      "properties": {
        "collectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Sum of all collection time"
        }
      }
    },
    "ProfileResultCollectorStats": {
      "type": "object",
      "properties": {
        "terminated": {
          "type": "boolean",
          "description": "If collection for this index slice was terminated early, such as by a timeout."
        },
        "segmentStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProfileResultSegmentStats"
          }
        },
        "totalCollectedCount": {
          "type": "integer",
          "format": "int32",
          "title": "Total docs collected by this collector"
        },
        "totalCollectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Sum of all segment collection time"
        },
        "additionalCollectorStats": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ProfileResultAdditionalCollectorStats"
          },
          "title": "Stats for additional collection operations"
        }
      }
    },
    "ProfileResultSearchStats": {
      "type": "object",
      "properties": {
        "totalCollectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Total time for all document collection"
        },
        "totalReduceTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Total time to reduce results from all parallel search slices"
        },
        "collectorStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProfileResultCollectorStats"
          }
        }
      }
    },
    "ProfileResultSegmentStats": {
      "type": "object",
      "properties": {
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "title": "Total docs in segment"
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Total live docs in segment"
        },
        "collectedCount": {
          "type": "integer",
          "format": "int32",
          "title": "How many docs were collected"
        },
        "relativeStartTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Start time of segment processing in relation to the start of the search phase"
        },
        "collectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Collection duration"
        }
      }
    },
    "ScriptParamListValue": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptParamValue"
          }
        }
      },
      "title": "list parameter value"
    },
    "ScriptParamNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "title": "null parameter value"
    },
    "ScriptParamStructValue": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ScriptParamValue"
          }
        }
      },
      "title": "map parameter value"
    },
    "ScriptParamValue": {
      "type": "object",
      "properties": {
        "textValue": {
          "type": "string"
        },
        "booleanValue": {
          "type": "boolean"
        },
        "intValue": {
          "type": "integer",
          "format": "int32"
        },
        "longValue": {
          "type": "string",
          "format": "int64"
        },
        "floatValue": {
          "type": "number",
          "format": "float"
        },
        "doubleValue": {
          "type": "number",
          "format": "double"
        },
        "nullValue": {
          "$ref": "#/definitions/ScriptParamNullValue"
        },
        "listValue": {
          "$ref": "#/definitions/ScriptParamListValue"
        },
        "structValue": {
          "$ref": "#/definitions/ScriptParamStructValue"
        }
      },
      "title": "script parameter entry"
    },
    "SearchResponseDiagnostics": {
      "type": "object",
      "properties": {
        "parsedQuery": {
          "type": "string",
          "title": "Query debug has been moved to ProfileResult"
        },
        "rewrittenQuery": {
          "type": "string"
        },
        "drillDownQuery": {
          "type": "string"
        },
        "firstPassSearchTimeMs": {
          "type": "number",
          "format": "double"
        },
        "highlightTimeMs": {
          "type": "number",
          "format": "double"
        },
        "getFieldsTimeMs": {
          "type": "number",
          "format": "double"
        },
        "newSnapshotSearcherOpenMs": {
          "type": "number",
          "format": "double"
        },
        "nrtWaitTimeMs": {
          "type": "number",
          "format": "double"
        },
        "facetTimeMs": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "double"
          }
        },
        "rescoreTimeMs": {
          "type": "number",
          "format": "double"
        },
        "rescorersTimeMs": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "double"
          }
        },
        "innerHitsDiagnostics": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/SearchResponseDiagnostics"
          }
        }
      }
    },
    "SearchResponseHit": {
      "type": "object",
      "properties": {
        "luceneDocId": {
          "type": "integer",
          "format": "int32"
        },
        "score": {
          "type": "number",
          "format": "double"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitCompositeFieldValue"
          }
        },
        "sortedFields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitCompositeFieldValue"
          }
        },
        "highlights": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitHighlights"
          },
          "title": "Field name to highlighted text fragments"
        },
        "explain": {
          "type": "string",
          "title": "Lucene explanation of the hit"
        },
        "innerHits": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverHitsResult"
          },
          "title": "InnerHits for each hit"
        }
      }
    },
    "SearchResponseSearchState": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64"
        },
        "searcherVersion": {
          "type": "string",
          "format": "int64"
        },
        "lastDocId": {
          "type": "integer",
          "format": "int32"
        },
        "lastFieldValues": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "lastScore": {
          "type": "number",
          "format": "float"
        }
      }
    },
    "TermInSetQueryDoubleTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        }
      }
    },
    "TermInSetQueryFloatTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      }
    },
    "TermInSetQueryIntTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "TermInSetQueryLongTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "TermInSetQueryTextTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "TotalHitsRelation": {
      "type": "string",
      "enum": [
        "EQUAL_TO",
        "GREATER_THAN_OR_EQUAL_TO"
      ],
      "default": "EQUAL_TO",
      "description": "* How the {TotalHits#value} should be interpreted.\n\n - EQUAL_TO: The total hit count is equal to {@link TotalHits#value}.\n - GREATER_THAN_OR_EQUAL_TO: The total hit count is greater than or equal to {@link TotalHits#value}."
    },
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "content_type": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody) returns\n      (google.protobuf.Empty);\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "luceneserverAddDocumentRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AddDocumentRequestMultiValuedField"
          }
        }
      }
    },
    "luceneserverAddDocumentResponse": {
      "type": "object",
      "properties": {
        "genId": {
          "type": "string"
        },
        "primaryId": {
          "type": "string",
          "title": "Unique identifier for the primary instance that processed the request"
        }
      }
    },
    "luceneserverAddReplicaResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string"
        }
      }
    },
    "luceneserverAnalyzer": {
      "type": "object",
      "properties": {
        "predefined": {
          "type": "string"
        },
        "custom": {
          "$ref": "#/definitions/luceneserverCustomAnalyzer"
        }
      }
    },
    "luceneserverAnalyzingSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        },
        "maxSurfaceFormsPerAnalyzedForm": {
          "type": "integer",
          "format": "int32"
        },
        "maxGraphExpansions": {
          "type": "integer",
          "format": "int32"
        },
        "preserveSep": {
          "type": "boolean"
        },
        "exactFirst": {
          "type": "boolean"
        }
      },
      "title": "Suggester that first analyzes the surface form, adds the analyzed form to a weighted FST, and then does the same thing at lookup time (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester"
    },
    "luceneserverBackupIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "resourceName": {
          "type": "string"
        },
        "completeDirectory": {
          "type": "boolean"
        },
        "stream": {
          "type": "boolean"
        }
      }
    },
    "luceneserverBackupIndexResponse": {
      "type": "object",
      "properties": {
        "dataVersionHash": {
          "type": "string"
        },
        "metadataVersionHash": {
          "type": "string"
        }
      }
    },
    "luceneserverBackupWarmingQueriesRequest": {
      "type": "object",
      "properties": {
        "index": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "numQueriesThreshold": {
          "type": "integer",
          "format": "int32"
        },
        "uptimeMinutesThreshold": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverBackupWarmingQueriesResponse": {
      "type": "object"
    },
    "luceneserverBooleanClause": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "occur": {
          "$ref": "#/definitions/BooleanClauseOccur"
        }
      },
      "description": "A clause in a BooleanQuery."
    },
    "luceneserverBooleanQuery": {
      "type": "object",
      "properties": {
        "clauses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverBooleanClause"
          }
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32"
        }
      },
      "description": "A query that matches documents using boolean combinations of other queries."
    },
    "luceneserverBucketOrder": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "What to use for sorting. This can be _count for Bucket count, or the name of a nested collector that supports ordering."
        },
        "order": {
          "$ref": "#/definitions/BucketOrderOrderType",
          "title": "Sorting order"
        }
      },
      "description": "Defines how Buckets should be ordered in BucketResult."
    },
    "luceneserverBucketResult": {
      "type": "object",
      "properties": {
        "buckets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BucketResultBucket"
          }
        },
        "totalBuckets": {
          "type": "integer",
          "format": "int32",
          "description": "Number of unique buckets, including those not in the buckets list."
        },
        "totalOtherCounts": {
          "type": "integer",
          "format": "int32",
          "description": "Number of other collected counts not represented in the buckets' counts."
        }
      }
    },
    "luceneserverBuildSuggestRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "infixSuggester": {
          "$ref": "#/definitions/luceneserverInfixSuggester",
          "title": "A suggester that matches terms anywhere in the input text, not just as a prefix. (see @lucene:org:server.InfixSuggester)"
        },
        "analyzingSuggester": {
          "$ref": "#/definitions/luceneserverAnalyzingSuggester",
          "title": "Suggester that first analyzes the surface form, adds the analyzed form to a weighted FST, and then does the same thing at lookup time (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester"
        },
        "fuzzySuggester": {
          "$ref": "#/definitions/luceneserverFuzzySuggester",
          "title": "Implements a fuzzy AnalyzingSuggester (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.FuzzySuggester"
        },
        "completionInfixSuggester": {
          "$ref": "#/definitions/luceneserverCompletionInfixSuggester",
          "title": "A suggester that matches terms anywhere in the input text. The implementation is different from InfixSuggester"
        },
        "fuzzyInfixSuggester": {
          "$ref": "#/definitions/luceneserverFuzzyInfixSuggester",
          "description": "A suggester that matches fuzzy terms in the input text."
        },
        "localSource": {
          "$ref": "#/definitions/luceneserverSuggestLocalSource"
        },
        "nonLocalSource": {
          "$ref": "#/definitions/luceneserverSuggestNonLocalSource"
        },
        "suggestName": {
          "type": "string"
        }
      }
    },
    "luceneserverBuildSuggestResponse": {
      "type": "object",
      "properties": {
        "sizeInBytes": {
          "type": "string",
          "format": "int64"
        },
        "count": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "luceneserverCollector": {
      "type": "object",
      "properties": {
        "terms": {
          "$ref": "#/definitions/luceneserverTermsCollector",
          "description": "Collector for aggregating based on term values."
        },
        "pluginCollector": {
          "$ref": "#/definitions/luceneserverPluginCollector"
        },
        "topHitsCollector": {
          "$ref": "#/definitions/luceneserverTopHitsCollector",
          "description": "Collector for getting top hits based on score or sorting."
        },
        "filter": {
          "$ref": "#/definitions/luceneserverFilterCollector",
          "title": "Collector that filters documents to nested collectors"
        },
        "max": {
          "$ref": "#/definitions/luceneserverMaxCollector",
          "description": "Collector for finding a max double value from collected documents."
        },
        "nestedCollectors": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollector"
          },
          "description": "Nested collectors that define sub-aggregations per bucket, supported by bucket based collectors."
        }
      },
      "description": "Definition of additional document collector."
    },
    "luceneserverCollectorResult": {
      "type": "object",
      "properties": {
        "bucketResult": {
          "$ref": "#/definitions/luceneserverBucketResult",
          "description": "Result of collector that produces buckets and counts."
        },
        "anyResult": {
          "$ref": "#/definitions/protobufAny",
          "title": "Flexible collector result for additional document collectors"
        },
        "hitsResult": {
          "$ref": "#/definitions/luceneserverHitsResult",
          "description": "Result of collector that returns document hits."
        },
        "filterResult": {
          "$ref": "#/definitions/luceneserverFilterResult",
          "description": "Result of collector that filters documents."
        },
        "doubleResult": {
          "type": "number",
          "format": "double",
          "description": "Result of collector that produces a single double value."
        }
      }
    },
    "luceneserverCommitRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverCommitResponse": {
      "type": "object",
      "properties": {
        "gen": {
          "type": "string",
          "format": "int64",
          "description": "sequence number of the last operation in the commit.  All sequence numbers less than this value\nwill be reflected in the commit, and all others will not."
        },
        "primaryId": {
          "type": "string",
          "title": "Unique identifier for the primary instance that processed the request"
        }
      }
    },
    "luceneserverCompletionInfixSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        }
      },
      "title": "A suggester that matches terms anywhere in the input text. The implementation is different from InfixSuggester"
    },
    "luceneserverCompletionQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Name of the field in the document to query, must be a SuggestField"
        },
        "queryType": {
          "$ref": "#/definitions/luceneserverCompletionQueryType",
          "title": "Completion query type, used when constructing the lucene completion query"
        },
        "text": {
          "type": "string",
          "title": "Completion text to be used in completion query"
        },
        "contexts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of contexts to filter by. Each result will have at least one of the contexts specified"
        }
      },
      "title": "A query used for suggest completion"
    },
    "luceneserverCompletionQueryType": {
      "type": "string",
      "enum": [
        "PREFIX_QUERY",
        "FUZZY_QUERY"
      ],
      "default": "PREFIX_QUERY",
      "title": "- PREFIX_QUERY: PrefixCompletionQuery within ContextCompletionQuery\n - FUZZY_QUERY: FuzzyCompletionQuery within ContextCompletionQuery"
    },
    "luceneserverConditionalTokenFilter": {
      "type": "object",
      "properties": {
        "condition": {
          "$ref": "#/definitions/luceneserverNameAndParams"
        },
        "tokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          }
        }
      }
    },
    "luceneserverConstantScoreQuery": {
      "type": "object",
      "properties": {
        "filter": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Query to determine matching documents"
        }
      },
      "description": "Query that produces a score of 1.0 (modifiable by query boost value) for documents that match the filter query."
    },
    "luceneserverCopyState": {
      "type": "object",
      "properties": {
        "infoBytesLength": {
          "type": "integer",
          "format": "int32"
        },
        "infoBytes": {
          "type": "string",
          "format": "byte"
        },
        "gen": {
          "type": "string",
          "format": "int64"
        },
        "version": {
          "type": "string",
          "format": "int64"
        },
        "filesMetadata": {
          "$ref": "#/definitions/luceneserverFilesMetadata"
        },
        "completedMergeFilesSize": {
          "type": "integer",
          "format": "int32"
        },
        "completedMergeFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "primaryGen": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "Holds incRef'd file level details for one point-in-time segment infos on the primary node."
    },
    "luceneserverCreateIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "existsWithId": {
          "type": "string",
          "description": "Set if state/data already exists in the data backend. Provides the UUID to identify and load the index."
        },
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Optional initial index settings"
        },
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Optional initial index live settings"
        },
        "fields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          },
          "title": "Optional initial index fields"
        },
        "start": {
          "type": "boolean",
          "title": "If this index should also be started, using IndexStartConfig configuration"
        }
      },
      "title": "Input to createIndex"
    },
    "luceneserverCreateIndexResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Response from Server to createIndex"
    },
    "luceneserverCreateSnapshotRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "openSearcher": {
          "type": "boolean"
        }
      },
      "description": "Creates a snapshot in the index, which is saved point-in-time view of the last commit in the\nindex such that no files referenced by that snapshot will be deleted by ongoing indexing until\nthe snapshot is released with @releaseSnapshot.  Note that this will reference the last commit,\nso be sure to call commit first if you have pending changes that you'd like to be included in\nthe snapshot.\u003cp\u003eThis can be used for backup purposes, i.e. after creating the snapshot you can\ncopy all referenced files to backup storage, and then release the snapshot once complete.\nTo restore the backup, just copy all the files back and restart the server.  It can also\nbe used for transactional purposes, i.e. if you sometimes need to search a specific snapshot\ninstead of the current live index.\u003cp\u003eCreating a snapshot is very fast (does not require any\nfile copying), but over time it will consume extra disk space as old segments are merged in\nthe index.  Be sure to release the snapshot once you're done.  Snapshots survive shutdown\nand restart of the server.  Returns all protected filenames referenced by this snapshot:\nthese files will not change and will not be deleted until the snapshot is released.\nThis returns the directories and files referenced by the snapshot."
    },
    "luceneserverCreateSnapshotResponse": {
      "type": "object",
      "properties": {
        "indexFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "taxonomyFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "stateFiles": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "snapshotId": {
          "$ref": "#/definitions/luceneserverSnapshotId"
        }
      }
    },
    "luceneserverCustomAnalyzer": {
      "type": "object",
      "properties": {
        "charFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          }
        },
        "tokenizer": {
          "$ref": "#/definitions/luceneserverNameAndParams"
        },
        "tokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          }
        },
        "conditionalTokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverConditionalTokenFilter"
          }
        },
        "defaultMatchVersion": {
          "type": "string"
        },
        "positionIncrementGap": {
          "$ref": "#/definitions/luceneserverIntObject"
        },
        "offsetGap": {
          "$ref": "#/definitions/luceneserverIntObject"
        }
      }
    },
    "luceneserverCustomRequest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverCustomResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverDeleteAllDocumentsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverDeleteAllDocumentsResponse": {
      "type": "object",
      "properties": {
        "genId": {
          "type": "string"
        }
      }
    },
    "luceneserverDeleteByQueryRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "query": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverQuery"
          }
        }
      }
    },
    "luceneserverDeleteIndexBackupRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "resourceName": {
          "type": "string"
        },
        "nDays": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverDeleteIndexBackupResponse": {
      "type": "object",
      "properties": {
        "deletedResourceDataHashes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deletedResourceMetadataHashes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deletedDataVersions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deletedMetadataVersions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverDeleteIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverDeleteIndexResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string"
        }
      }
    },
    "luceneserverDisjunctionMaxQuery": {
      "type": "object",
      "properties": {
        "disjuncts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverQuery"
          }
        },
        "tieBreakerMultiplier": {
          "type": "number",
          "format": "float"
        }
      },
      "description": "A query that generates the union of documents produced by its subqueries, and that scores each document with the\nmaximum score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries."
    },
    "luceneserverDummyResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string"
        }
      }
    },
    "luceneserverExistsQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        }
      },
      "description": "A query that matches documents which contain a value for a field."
    },
    "luceneserverFacet": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "string"
        },
        "paths": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "numericRange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNumericRangeType"
          }
        },
        "useOrdsCache": {
          "type": "boolean"
        },
        "labels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "topN": {
          "type": "integer",
          "format": "int32"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        },
        "sampleTopDocs": {
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "luceneserverFacetHierarchyPath": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverFacetResult": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "string"
        },
        "path": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "value": {
          "type": "number",
          "format": "double"
        },
        "labelValues": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverLabelAndValue"
          }
        },
        "childCount": {
          "type": "string",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "luceneserverFacetType": {
      "type": "string",
      "enum": [
        "NO_FACETS",
        "FLAT",
        "HIERARCHY",
        "NUMERIC_RANGE",
        "SORTED_SET_DOC_VALUES"
      ],
      "default": "NO_FACETS",
      "description": "Whether/How this field should index facets, and how."
    },
    "luceneserverFetchTask": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object"
        }
      }
    },
    "luceneserverField": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/luceneserverFieldType"
        },
        "search": {
          "type": "boolean"
        },
        "store": {
          "type": "boolean"
        },
        "storeDocValues": {
          "type": "boolean"
        },
        "sort": {
          "type": "boolean"
        },
        "tokenize": {
          "type": "boolean"
        },
        "group": {
          "type": "boolean"
        },
        "multiValued": {
          "type": "boolean"
        },
        "highlight": {
          "type": "boolean"
        },
        "omitNorms": {
          "type": "boolean"
        },
        "dateTimeFormat": {
          "type": "string"
        },
        "postingsFormat": {
          "type": "string"
        },
        "docValuesFormat": {
          "type": "string"
        },
        "indexOptions": {
          "$ref": "#/definitions/luceneserverIndexOptions"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "title": "TODO make analyzers message types i.e. StandardAnalyzer, EnglishAnalyzer, CustomAnalyzer etc"
        },
        "indexAnalyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "searchAnalyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "termVectors": {
          "$ref": "#/definitions/luceneserverTermVectors"
        },
        "similarity": {
          "type": "string",
          "title": "TODO make similarity message types i.d. DefaultSimilarity, CustomSimilarity, BM25Similarity;"
        },
        "facet": {
          "$ref": "#/definitions/luceneserverFacetType"
        },
        "facetIndexFieldName": {
          "type": "string"
        },
        "additionalProperties": {
          "type": "object"
        },
        "similarityParams": {
          "type": "object"
        },
        "childFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          }
        },
        "eagerGlobalOrdinals": {
          "type": "boolean"
        },
        "nestedDoc": {
          "type": "boolean"
        },
        "vectorDimensions": {
          "type": "integer",
          "format": "int32"
        },
        "eagerFieldGlobalOrdinals": {
          "type": "boolean",
          "description": "If field based global ordinals should be built up front, otherwise this is done lazily on first access. Currently only for fields with text doc values (TEXT/ATOM)."
        }
      }
    },
    "luceneserverFieldDefRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "field": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          }
        }
      },
      "title": "Input to registerFields"
    },
    "luceneserverFieldDefResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Response from Server for registerFields"
    },
    "luceneserverFieldType": {
      "type": "string",
      "enum": [
        "ATOM",
        "TEXT",
        "BOOLEAN",
        "LONG",
        "INT",
        "DOUBLE",
        "FLOAT",
        "LAT_LON",
        "DATE_TIME",
        "VIRTUAL",
        "INTERNAL",
        "CUSTOM",
        "_ID",
        "POLYGON",
        "OBJECT",
        "VECTOR",
        "CONTEXT_SUGGEST"
      ],
      "default": "ATOM",
      "description": "- VIRTUAL: TODO name this \"dynamic\" instead of \"virtual\"?\n - INTERNAL: TODO need tests for internal:\n - VECTOR: List of float values",
      "title": "Type of the field"
    },
    "luceneserverFileMetadata": {
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string"
        },
        "len": {
          "type": "string",
          "format": "int64"
        },
        "checksum": {
          "type": "string",
          "format": "int64"
        },
        "headerLength": {
          "type": "integer",
          "format": "int32"
        },
        "header": {
          "type": "string",
          "format": "byte"
        },
        "footerLength": {
          "type": "integer",
          "format": "int32"
        },
        "footer": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "luceneserverFilesMetadata": {
      "type": "object",
      "properties": {
        "numFiles": {
          "type": "integer",
          "format": "int32"
        },
        "fileMetadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFileMetadata"
          }
        }
      }
    },
    "luceneserverFilterCollector": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "description": "Only propagate documents that match the given query."
        },
        "setQuery": {
          "$ref": "#/definitions/luceneserverTermInSetQuery",
          "description": "Specialized implementation for set queries, checks if field doc values are in the provided set. This can be useful for large set sizes with lower recall, where building the scorer would be expensive."
        }
      },
      "description": "Definition of filtering collector, there must be at least one nested collector specified in the Collector message."
    },
    "luceneserverFilterResult": {
      "type": "object",
      "properties": {
        "docCount": {
          "type": "integer",
          "format": "int32",
          "description": "Number of documents that passed the filter."
        },
        "nestedCollectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "description": "Results from nested collectors."
        }
      }
    },
    "luceneserverForceMergeDeletesRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "doWait": {
          "type": "boolean"
        }
      }
    },
    "luceneserverForceMergeDeletesResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/luceneserverForceMergeDeletesResponseStatus"
        }
      }
    },
    "luceneserverForceMergeDeletesResponseStatus": {
      "type": "string",
      "enum": [
        "FORCE_MERGE_DELETES_COMPLETED",
        "FORCE_MERGE_DELETES_SUBMITTED"
      ],
      "default": "FORCE_MERGE_DELETES_COMPLETED"
    },
    "luceneserverForceMergeRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "maxNumSegments": {
          "type": "integer",
          "format": "int32"
        },
        "doWait": {
          "type": "boolean"
        }
      }
    },
    "luceneserverForceMergeResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/luceneserverForceMergeResponseStatus"
        }
      }
    },
    "luceneserverForceMergeResponseStatus": {
      "type": "string",
      "enum": [
        "FORCE_MERGE_COMPLETED",
        "FORCE_MERGE_SUBMITTED"
      ],
      "default": "FORCE_MERGE_COMPLETED"
    },
    "luceneserverFunctionFilterQuery": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        }
      },
      "title": "A query that retrieves all documents with a positive score calculated by the script"
    },
    "luceneserverFunctionScoreQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        }
      },
      "description": "A query that wraps another query and uses custom scoring logic to compute the wrapped query's score."
    },
    "luceneserverFuzzyInfixSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        },
        "minFuzzyLength": {
          "type": "integer",
          "format": "int32"
        },
        "nonFuzzyPrefix": {
          "type": "integer",
          "format": "int32"
        },
        "maxEdits": {
          "type": "integer",
          "format": "int32"
        },
        "transpositions": {
          "type": "boolean"
        },
        "unicodeAware": {
          "type": "boolean"
        }
      },
      "title": "A suggester that matches fuzzy terms in the input text"
    },
    "luceneserverFuzzyParams": {
      "type": "object",
      "properties": {
        "maxEdits": {
          "type": "integer",
          "format": "int32"
        },
        "prefixLength": {
          "type": "integer",
          "format": "int32"
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32"
        },
        "transpositions": {
          "type": "boolean"
        }
      }
    },
    "luceneserverFuzzySuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        },
        "maxSurfaceFormsPerAnalyzedForm": {
          "type": "integer",
          "format": "int32"
        },
        "maxGraphExpansions": {
          "type": "integer",
          "format": "int32"
        },
        "preserveSep": {
          "type": "boolean"
        },
        "exactFirst": {
          "type": "boolean"
        },
        "minFuzzyLength": {
          "type": "integer",
          "format": "int32"
        },
        "nonFuzzyPrefix": {
          "type": "integer",
          "format": "int32"
        },
        "maxEdits": {
          "type": "integer",
          "format": "int32"
        },
        "transpositions": {
          "type": "boolean"
        },
        "unicodeAware": {
          "type": "boolean"
        }
      },
      "title": "Implements a fuzzy AnalyzingSuggester (see @lucene:suggest:org.apache.lucene.search.suggest.analyzing.FuzzySuggester"
    },
    "luceneserverGeoBoundingBoxQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "topLeft": {
          "$ref": "#/definitions/typeLatLng"
        },
        "bottomRight": {
          "$ref": "#/definitions/typeLatLng"
        }
      },
      "description": "A query that matches documents with geopoint within the geo box."
    },
    "luceneserverGeoPointQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "point": {
          "$ref": "#/definitions/typeLatLng"
        }
      },
      "description": "A query that matches documents with polygon that contains the geo point."
    },
    "luceneserverGeoPolygonQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "polygons": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverPolygon"
          },
          "title": "Geo polygons to search for containing points"
        }
      },
      "title": "A query that matches documents with geo points within polygons"
    },
    "luceneserverGeoRadiusQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "center": {
          "$ref": "#/definitions/typeLatLng"
        },
        "radius": {
          "type": "string"
        }
      },
      "title": "A query that matches documents with geo point within the radius of target geo point"
    },
    "luceneserverGetAllSnapshotGenResponse": {
      "type": "object",
      "properties": {
        "indexGens": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "luceneserverGetNodesResponse": {
      "type": "object",
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNodeInfo"
          }
        }
      }
    },
    "luceneserverHealthCheckResponse": {
      "type": "object",
      "properties": {
        "health": {
          "$ref": "#/definitions/luceneserverTransferStatusCode"
        }
      }
    },
    "luceneserverHighlight": {
      "type": "object",
      "properties": {
        "settings": {
          "$ref": "#/definitions/HighlightSettings",
          "title": "Highlight settings"
        },
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Fields to highlight"
        },
        "field_settings": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HighlightSettings"
          },
          "title": "Map of field name to highlight settings for field, overrides request level highlight settings"
        }
      },
      "title": "Specify how to highlight matched text in SearchRequest"
    },
    "luceneserverHighlightType": {
      "type": "string",
      "enum": [
        "DEFAULT",
        "FAST_VECTOR",
        "PLAIN",
        "CUSTOM"
      ],
      "default": "DEFAULT",
      "title": "- DEFAULT: When DEFAULT is set in global setting, use fast vector highlighter; when set for field setting, use the type from the global setting.\n - PLAIN: not supported yet"
    },
    "luceneserverHitsResult": {
      "type": "object",
      "properties": {
        "totalHits": {
          "$ref": "#/definitions/luceneserverTotalHits",
          "description": "Total hit information."
        },
        "hits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchResponseHit"
          },
          "description": "Ordered hits with scoring/sorting info and retrieved fields."
        }
      }
    },
    "luceneserverIndexLiveSettings": {
      "type": "object",
      "properties": {
        "maxRefreshSec": {
          "type": "number",
          "format": "double",
          "title": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen), default: 1.0"
        },
        "minRefreshSec": {
          "type": "number",
          "format": "double",
          "title": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen), default: 0.05"
        },
        "maxSearcherAgeSec": {
          "type": "number",
          "format": "double",
          "title": "Non-current searchers older than this are pruned, default: 60.0"
        },
        "indexRamBufferSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Size (in MB) of IndexWriter's RAM buffer, default: 16.0"
        },
        "addDocumentsMaxBufferLen": {
          "type": "integer",
          "format": "int32",
          "title": "Max number of documents to add at a time, default: 100"
        },
        "sliceMaxDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of documents allowed in a parallel search slice, default: 250,000"
        },
        "sliceMaxSegments": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of segments allowed in a parallel search slice, default: 5"
        },
        "virtualShards": {
          "type": "integer",
          "format": "int32",
          "title": "Number of virtual shards to use for this index, default: 1"
        },
        "maxMergedSegmentMB": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum sized segment to produce during normal merging, default: 5GB"
        },
        "segmentsPerTier": {
          "type": "integer",
          "format": "int32",
          "title": "Number of segments per tier used by TieredMergePolicy, default: 10"
        },
        "defaultSearchTimeoutSec": {
          "type": "number",
          "format": "double",
          "title": "Timeout value to used when not specified in the search request, or 0 for no timeout, default: 0"
        },
        "defaultSearchTimeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "title": "Timeout check every value to use when not specified in the search request, or 0 for none, default: 0"
        },
        "defaultTerminateAfter": {
          "type": "integer",
          "format": "int32",
          "title": "Terminate after value to use when not specified in the search request, or 0 for none, default: 0"
        },
        "maxMergePreCopyDurationSec": {
          "type": "string",
          "format": "uint64",
          "title": "Merge precopy would be stopped after this time, or 0 for no checks, default: 0"
        },
        "verboseMetrics": {
          "type": "boolean",
          "title": "Collect and publish additional index metrics, which may be more expensive in terms of volume, memory and/or compute, default: false"
        }
      }
    },
    "luceneserverIndexOptions": {
      "type": "string",
      "enum": [
        "DOCS_FREQS_POSITIONS",
        "DOCS",
        "DOCS_FREQS",
        "DOCS_FREQS_POSITIONS_OFFSETS"
      ],
      "default": "DOCS_FREQS_POSITIONS",
      "description": "How the tokens should be indexed."
    },
    "luceneserverIndexSettings": {
      "type": "object",
      "properties": {
        "nrtCachingDirectoryMaxMergeSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Largest merged segment size to cache in RAMDirectory, default: 5.0MB"
        },
        "nrtCachingDirectoryMaxSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Largest overall size for all files cached in NRTCachingDirectory, default: 60.0MB"
        },
        "concurrentMergeSchedulerMaxThreadCount": {
          "type": "integer",
          "format": "int32",
          "title": "How many merge threads to allow at once"
        },
        "concurrentMergeSchedulerMaxMergeCount": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum backlog of pending merges before indexing threads are stalled"
        },
        "indexSort": {
          "$ref": "#/definitions/luceneserverSortFields",
          "title": "Index time sorting; can only be written once\", SearchHandler.SORT_TYPE"
        },
        "indexMergeSchedulerAutoThrottle": {
          "type": "boolean",
          "title": "Turn on/off the merge scheduler's auto throttling, default: off"
        },
        "directory": {
          "type": "string",
          "title": "Base Directory implementation to use (NRTCachingDirectory will wrap this) either one of the core implementations (FSDirectory, MMapDirectory, NIOFSDirectory, SimpleFSDirectory, RAMDirectory (for temporary indices!) or a fully qualified path to a Directory implementation that has a public constructor taking a single File argument default: FSDirectory"
        }
      }
    },
    "luceneserverIndexStatsResponse": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "statsResponse": {
          "$ref": "#/definitions/luceneserverStatsResponse"
        }
      }
    },
    "luceneserverIndicesResponse": {
      "type": "object",
      "properties": {
        "indicesResponse": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverIndexStatsResponse"
          }
        }
      }
    },
    "luceneserverInfixSuggester": {
      "type": "object",
      "properties": {
        "analyzer": {
          "type": "string"
        },
        "indexAnalyzer": {
          "type": "string"
        },
        "queryAnalyzer": {
          "type": "string"
        }
      },
      "title": "A suggester that matches terms anywhere in the input text, not just as a prefix. (see @lucene:org:server.InfixSuggester)"
    },
    "luceneserverInnerHit": {
      "type": "object",
      "properties": {
        "query_nested_path": {
          "type": "string",
          "description": "Nested path to search against assuming same index as the parent Query."
        },
        "start_hit": {
          "type": "integer",
          "format": "int32",
          "title": "Which hit to start from (for pagination); default: 0"
        },
        "top_hits": {
          "type": "integer",
          "format": "int32",
          "description": "How many top hits to retrieve; default: 3. It limits the hits returned, starting from index 0. For pagination: set it to startHit + window_size."
        },
        "inner_query": {
          "$ref": "#/definitions/luceneserverQuery",
          "description": "InnerHit query to query against the nested documents specified by queryNestedPath."
        },
        "retrieve_fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Fields to retrieve; Parent's fields except its id field are unavailable in the innerHit."
        },
        "query_sort": {
          "$ref": "#/definitions/luceneserverQuerySortField",
          "description": "Sort hits by field (default is by relevance)."
        },
        "highlight": {
          "$ref": "#/definitions/luceneserverHighlight",
          "description": "Highlight the children documents."
        }
      },
      "title": "Inner Hit search request"
    },
    "luceneserverIntObject": {
      "type": "object",
      "properties": {
        "int": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "Used to be able to check if a value was set"
    },
    "luceneserverLabelAndValue": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "value": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "luceneserverLiveSettingsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "maxRefreshSec": {
          "type": "number",
          "format": "double",
          "description": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen)."
        },
        "minRefreshSec": {
          "type": "number",
          "format": "double",
          "description": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen)."
        },
        "maxSearcherAgeSec": {
          "type": "number",
          "format": "double",
          "description": "Non-current searchers older than this are pruned."
        },
        "indexRamBufferSizeMB": {
          "type": "number",
          "format": "double",
          "description": "Size (in MB) of IndexWriter's RAM buffer."
        },
        "addDocumentsMaxBufferLen": {
          "type": "integer",
          "format": "int32",
          "description": "Max number of documents to add at a time."
        },
        "sliceMaxDocs": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of documents allowed in a parallel search slice."
        },
        "sliceMaxSegments": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of segments allowed in a parallel search slice."
        },
        "virtualShards": {
          "type": "integer",
          "format": "int32",
          "description": "Number of virtual shards to use for this index."
        },
        "maxMergedSegmentMB": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum sized segment to produce during normal merging"
        },
        "segmentsPerTier": {
          "type": "integer",
          "format": "int32",
          "title": "Number of segments per tier used by TieredMergePolicy"
        },
        "defaultSearchTimeoutSec": {
          "type": "number",
          "format": "double",
          "description": "Timeout value to used when not specified in the search request."
        },
        "defaultSearchTimeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "description": "Timeout check every value to use when not specified in the search request."
        },
        "defaultTerminateAfter": {
          "type": "integer",
          "format": "int32",
          "description": "Terminate after value to use when not specified in the search request."
        }
      },
      "title": "Input to liveSettings"
    },
    "luceneserverLiveSettingsResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Response from Server to liveSettings"
    },
    "luceneserverLiveSettingsV2Request": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        },
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Live settings to merge into existing live settings, or unset to get current live settings"
        },
        "local": {
          "type": "boolean",
          "description": "When set to true, live settings changes are only applied to the local node. These changes are ephemeral, so will not persist through a restart. Also, the live settings returned in the response will contain the local overrides only when this flag is true."
        }
      }
    },
    "luceneserverLiveSettingsV2Response": {
      "type": "object",
      "properties": {
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Current live settings, including default values"
        }
      }
    },
    "luceneserverMatchOperator": {
      "type": "string",
      "enum": [
        "SHOULD",
        "MUST"
      ],
      "default": "SHOULD"
    },
    "luceneserverMatchPhrasePrefixQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Field in the document to query."
        },
        "query": {
          "type": "string",
          "description": "The text to query with."
        },
        "slop": {
          "type": "integer",
          "format": "int32",
          "description": "Edit distance between respective positions of tokens generated by analyzing this query and the positions of terms in a document."
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "description": "Analyzer used to analyze the query. If not provided, the default search analyzer for the field would be used instead."
        },
        "max_expansions": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of terms to which the last provided term of the query value will expand. Defaults to 50."
        }
      },
      "title": "A query that matches documents containing terms in the same order as those in the analyzed query string. The final analyzed token is treated as a prefix"
    },
    "luceneserverMatchPhraseQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "query": {
          "type": "string"
        },
        "slop": {
          "type": "integer",
          "format": "int32"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        }
      },
      "description": "A query that analyzes the text before finding matching documents. The tokens resulting from the analysis are combined into a PhraseQuery."
    },
    "luceneserverMatchQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "query": {
          "type": "string"
        },
        "operator": {
          "$ref": "#/definitions/luceneserverMatchOperator"
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "fuzzyParams": {
          "$ref": "#/definitions/luceneserverFuzzyParams"
        }
      },
      "description": "A query that analyzes the text before finding matching documents. The tokens resulting from the analysis are combined using term queries in boolean clauses."
    },
    "luceneserverMaxCollector": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script to produce a double value"
        }
      },
      "description": "Definition of collector to find a max double value over documents. Currently only allows for script based value production."
    },
    "luceneserverMode": {
      "type": "string",
      "enum": [
        "STANDALONE",
        "PRIMARY",
        "REPLICA"
      ],
      "default": "STANDALONE"
    },
    "luceneserverMultiFunctionScoreQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Main query to produce recalled docs and scores, which will be modified by the final function score"
        },
        "functions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MultiFunctionScoreQueryFilterFunction"
          },
          "title": "Functions to produce final function score"
        },
        "score_mode": {
          "$ref": "#/definitions/MultiFunctionScoreQueryFunctionScoreMode",
          "title": "Method to combine functions scores"
        },
        "boost_mode": {
          "$ref": "#/definitions/MultiFunctionScoreQueryBoostMode",
          "title": "Method to modify query document scores with final function score"
        },
        "min_score": {
          "type": "number",
          "format": "float",
          "description": "Optional minimal score to match a document. By default, it's 0."
        },
        "min_excluded": {
          "type": "boolean",
          "title": "Determine minimal score is excluded or not. By default, it's false;"
        }
      },
      "title": "A query to modify the score of documents with a given set of functions"
    },
    "luceneserverMultiMatchQuery": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "query": {
          "type": "string"
        },
        "fieldBoosts": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "float"
          }
        },
        "operator": {
          "$ref": "#/definitions/luceneserverMatchOperator"
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer"
        },
        "fuzzyParams": {
          "$ref": "#/definitions/luceneserverFuzzyParams"
        },
        "tieBreakerMultiplier": {
          "type": "number",
          "format": "float"
        },
        "type": {
          "$ref": "#/definitions/MultiMatchQueryMatchType",
          "description": "Type defining match behavior of query."
        },
        "slop": {
          "type": "integer",
          "format": "int32",
          "description": "Edit distance between respective positions of tokens generated by analyzing this query and the positions of terms in a document, applies to PHRASE_PREFIX type matching."
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of terms to which the prefix token will expand when using PHRASE_PREFIX matching. Defaults to 50."
        }
      },
      "description": "A query that creates a match query for each field provided and wraps all the match queries in a disjunction max query."
    },
    "luceneserverNameAndParams": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "luceneserverNestedQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "path": {
          "type": "string"
        },
        "scoreMode": {
          "$ref": "#/definitions/NestedQueryScoreMode"
        }
      }
    },
    "luceneserverNodeInfo": {
      "type": "object",
      "properties": {
        "hostname": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverNumericRangeType": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "min": {
          "type": "string",
          "format": "int64"
        },
        "minInclusive": {
          "type": "boolean"
        },
        "max": {
          "type": "string",
          "format": "int64"
        },
        "maxInclusive": {
          "type": "boolean"
        }
      }
    },
    "luceneserverOneHighlight": {
      "type": "object",
      "properties": {
        "isHit": {
          "type": "boolean"
        },
        "text": {
          "type": "string"
        }
      }
    },
    "luceneserverOneSuggestLookupResponse": {
      "type": "object",
      "properties": {
        "suggestLookupHighlight": {
          "$ref": "#/definitions/luceneserverSuggestLookupHighlight",
          "title": "Expert: custom Object to hold the result of a highlighted suggestion (currently only works with AnalyzingInfixSuggester)"
        },
        "key": {
          "type": "string",
          "title": "the key's text"
        },
        "weight": {
          "type": "string",
          "format": "int64"
        },
        "payload": {
          "type": "string"
        }
      }
    },
    "luceneserverPhraseQuery": {
      "type": "object",
      "properties": {
        "slop": {
          "type": "integer",
          "format": "int32",
          "description": "Edit distance between respective positions of terms as defined in this PhraseQuery and the positions\nof terms in a document."
        },
        "field": {
          "type": "string"
        },
        "terms": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "A Query that matches documents containing a particular sequence of terms."
    },
    "luceneserverPluginCollector": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object"
        }
      },
      "title": "Defines an entry point for using a collector from a plugin"
    },
    "luceneserverPluginRescorer": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "params": {
          "type": "object"
        }
      },
      "title": "Defines an entry point for using a rescorer from plugin"
    },
    "luceneserverPoint": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double"
        },
        "longitude": {
          "type": "number",
          "format": "double"
        }
      },
      "title": "Point representation"
    },
    "luceneserverPolygon": {
      "type": "object",
      "properties": {
        "points": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/typeLatLng"
          },
          "description": "Points defining the polygon, conforming to the https://geojson.org/ standard. The polygon must not be self-crossing, otherwise may result in unexpected behavior. Polygons cannot cross the 180th meridian. Instead, use two polygons: one on each side."
        },
        "holes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverPolygon"
          },
          "description": "Specify holes in the polygon. Hole polygons cannot themselves contain holes."
        }
      },
      "title": "Polygon defined by a list of geo points"
    },
    "luceneserverPrefixQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Document field name."
        },
        "prefix": {
          "type": "string",
          "description": "Prefix to search for."
        },
        "rewrite": {
          "$ref": "#/definitions/luceneserverRewriteMethod",
          "description": "Method used to rewrite the query."
        },
        "rewriteTopTermsSize": {
          "type": "integer",
          "format": "int32",
          "description": "Specifies the size to use for the TOP_TERMS* rewrite methods."
        }
      },
      "description": "A query that matches documents that contain a specific prefix in a provided field."
    },
    "luceneserverProfileResult": {
      "type": "object",
      "properties": {
        "searchStats": {
          "$ref": "#/definitions/ProfileResultSearchStats"
        },
        "parsedQuery": {
          "type": "string"
        },
        "rewrittenQuery": {
          "type": "string"
        },
        "drillDownQuery": {
          "type": "string"
        }
      },
      "title": "Defines detailed profiling stats for queries that set profile=true"
    },
    "luceneserverQuery": {
      "type": "object",
      "properties": {
        "queryType": {
          "$ref": "#/definitions/luceneserverQueryType"
        },
        "boost": {
          "type": "number",
          "format": "float"
        },
        "booleanQuery": {
          "$ref": "#/definitions/luceneserverBooleanQuery"
        },
        "phraseQuery": {
          "$ref": "#/definitions/luceneserverPhraseQuery"
        },
        "functionScoreQuery": {
          "$ref": "#/definitions/luceneserverFunctionScoreQuery"
        },
        "termQuery": {
          "$ref": "#/definitions/luceneserverTermQuery"
        },
        "termInSetQuery": {
          "$ref": "#/definitions/luceneserverTermInSetQuery"
        },
        "disjunctionMaxQuery": {
          "$ref": "#/definitions/luceneserverDisjunctionMaxQuery"
        },
        "matchQuery": {
          "$ref": "#/definitions/luceneserverMatchQuery"
        },
        "matchPhraseQuery": {
          "$ref": "#/definitions/luceneserverMatchPhraseQuery"
        },
        "multiMatchQuery": {
          "$ref": "#/definitions/luceneserverMultiMatchQuery"
        },
        "rangeQuery": {
          "$ref": "#/definitions/luceneserverRangeQuery"
        },
        "geoBoundingBoxQuery": {
          "$ref": "#/definitions/luceneserverGeoBoundingBoxQuery"
        },
        "geoPointQuery": {
          "$ref": "#/definitions/luceneserverGeoPointQuery"
        },
        "nestedQuery": {
          "$ref": "#/definitions/luceneserverNestedQuery"
        },
        "existsQuery": {
          "$ref": "#/definitions/luceneserverExistsQuery"
        },
        "geoRadiusQuery": {
          "$ref": "#/definitions/luceneserverGeoRadiusQuery"
        },
        "functionFilterQuery": {
          "$ref": "#/definitions/luceneserverFunctionFilterQuery"
        },
        "completionQuery": {
          "$ref": "#/definitions/luceneserverCompletionQuery"
        },
        "multiFunctionScoreQuery": {
          "$ref": "#/definitions/luceneserverMultiFunctionScoreQuery"
        },
        "matchPhrasePrefixQuery": {
          "$ref": "#/definitions/luceneserverMatchPhrasePrefixQuery"
        },
        "prefixQuery": {
          "$ref": "#/definitions/luceneserverPrefixQuery"
        },
        "constantScoreQuery": {
          "$ref": "#/definitions/luceneserverConstantScoreQuery"
        },
        "geoPolygonQuery": {
          "$ref": "#/definitions/luceneserverGeoPolygonQuery"
        }
      },
      "description": "Defines a full query consisting of a QueryNode which may be one of several types."
    },
    "luceneserverQueryRescorer": {
      "type": "object",
      "properties": {
        "rescoreQuery": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "queryWeight": {
          "type": "number",
          "format": "double"
        },
        "rescoreQueryWeight": {
          "type": "number",
          "format": "double"
        }
      },
      "title": "Defines a rescorer which uses query to rescore documents in the second pass"
    },
    "luceneserverQuerySortField": {
      "type": "object",
      "properties": {
        "doDocScores": {
          "type": "boolean"
        },
        "doMaxScore": {
          "type": "boolean"
        },
        "fields": {
          "$ref": "#/definitions/luceneserverSortFields"
        }
      }
    },
    "luceneserverQueryType": {
      "type": "string",
      "enum": [
        "NONE",
        "BOOLEAN_QUERY",
        "PHRASE_QUERY",
        "FUNCTION_SCORE_QUERY",
        "TERM_QUERY",
        "TERM_IN_SET_QUERY",
        "DISJUNCTION_MAX",
        "MATCH",
        "MATCH_PHRASE",
        "MULTI_MATCH",
        "RANGE",
        "GEO_BOUNDING_BOX",
        "GEO_POINT",
        "NESTED",
        "EXISTS",
        "GEO_RADIUS",
        "COMPLETION",
        "MULTI_FUNCTION_SCORE_QUERY",
        "MATCH_PHRASE_PREFIX",
        "PREFIX",
        "CONSTANT_SCORE_QUERY",
        "GEO_POLYGON"
      ],
      "default": "NONE",
      "description": "Defines different types of QueryNodes."
    },
    "luceneserverRangeQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string"
        },
        "lower": {
          "type": "string"
        },
        "upper": {
          "type": "string"
        },
        "lowerExclusive": {
          "type": "boolean"
        },
        "upperExclusive": {
          "type": "boolean"
        }
      },
      "description": "A query that matches documents with values within the specified range. The lower and upper values though provided as strings will be converted to the type of the field. This works with INT, LONG, FLOAT, DOUBLE and DATE_TIME field types."
    },
    "luceneserverRawFileChunk": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string",
          "format": "byte"
        },
        "seqNum": {
          "type": "integer",
          "format": "int32",
          "title": "sequence number for this chunk, only used for acked file copy"
        },
        "ack": {
          "type": "boolean",
          "title": "if this chunk should be acked, only used for acked file copy"
        }
      }
    },
    "luceneserverRefreshRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverRefreshResponse": {
      "type": "object",
      "properties": {
        "refreshTimeMS": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "luceneserverReleaseSnapshotRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "snapshotId": {
          "$ref": "#/definitions/luceneserverSnapshotId"
        }
      }
    },
    "luceneserverReleaseSnapshotResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean"
        }
      }
    },
    "luceneserverReloadStateRequest": {
      "type": "object"
    },
    "luceneserverReloadStateResponse": {
      "type": "object"
    },
    "luceneserverRescorer": {
      "type": "object",
      "properties": {
        "windowSize": {
          "type": "integer",
          "format": "int32"
        },
        "queryRescorer": {
          "$ref": "#/definitions/luceneserverQueryRescorer"
        },
        "pluginRescorer": {
          "$ref": "#/definitions/luceneserverPluginRescorer"
        },
        "name": {
          "type": "string",
          "title": "Must be unique for each Rescorer"
        }
      },
      "title": "Defines a rescorer which is executed after the first search pass"
    },
    "luceneserverRestoreIndex": {
      "type": "object",
      "properties": {
        "serviceName": {
          "type": "string"
        },
        "resourceName": {
          "type": "string"
        },
        "deleteExistingData": {
          "type": "boolean"
        }
      }
    },
    "luceneserverRewriteMethod": {
      "type": "string",
      "enum": [
        "CONSTANT_SCORE",
        "CONSTANT_SCORE_BOOLEAN",
        "SCORING_BOOLEAN",
        "TOP_TERMS_BLENDED_FREQS",
        "TOP_TERMS_BOOST",
        "TOP_TERMS"
      ],
      "default": "CONSTANT_SCORE",
      "description": "- CONSTANT_SCORE: Uses the CONSTANT_SCORE_BOOLEAN method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.\n - CONSTANT_SCORE_BOOLEAN: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each matching term.\n - SCORING_BOOLEAN: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each matching term. Calculates the relevance score for each matching document.\n - TOP_TERMS_BLENDED_FREQS: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each matching term. Calculates a relevance score for each matching document as if all terms had the same frequency, the maximum frequency of all matching terms. The final BooleanQuery query only includes Term queries for the top N (specified separately) scoring terms.\n - TOP_TERMS_BOOST: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each matching term. Assigns each matching document a relevance score equal to the boost parameter. The final BooleanQuery query only includes Term queries for the top N (specified separately) terms.\n - TOP_TERMS: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each matching term. Calculates a relevance score for each matching document. The final BooleanQuery query only includes Term queries for the top N (specified separately) scoring terms.",
      "title": "Method used to rewrite a MultiTermQuery"
    },
    "luceneserverScript": {
      "type": "object",
      "properties": {
        "lang": {
          "type": "string"
        },
        "source": {
          "type": "string"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ScriptParamValue"
          }
        }
      }
    },
    "luceneserverSearchRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "startHit": {
          "type": "integer",
          "format": "int32"
        },
        "topHits": {
          "type": "integer",
          "format": "int32"
        },
        "timeoutSec": {
          "type": "number",
          "format": "double",
          "description": "Maximum number of seconds spent on each collection phase; note that for\nmulti-pass searches (e.g. query-time grouping), this timeout applies to each phase."
        },
        "retrieveFields": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "queryText": {
          "type": "string"
        },
        "virtualFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverVirtualField"
          }
        },
        "query": {
          "$ref": "#/definitions/luceneserverQuery"
        },
        "querySort": {
          "$ref": "#/definitions/luceneserverQuerySortField"
        },
        "indexGen": {
          "type": "string",
          "format": "int64"
        },
        "version": {
          "type": "string",
          "format": "int64"
        },
        "snapshot": {
          "type": "string"
        },
        "totalHitsThreshold": {
          "type": "integer",
          "format": "int32"
        },
        "facets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacet"
          }
        },
        "fetchTasks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFetchTask"
          }
        },
        "disallowPartialResults": {
          "type": "boolean"
        },
        "queryNestedPath": {
          "type": "string"
        },
        "rescorers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverRescorer"
          }
        },
        "profile": {
          "type": "boolean",
          "title": "If detailed request execution profiling should be included in the response"
        },
        "timeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "description": "Check the search timeout condition after each collection of n documents in a segment. If 0, timeout is only checked on the segment boundary."
        },
        "collectors": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollector"
          },
          "description": "Additional document collectors. Provides support for operations such as aggregation."
        },
        "terminateAfter": {
          "type": "integer",
          "format": "int32",
          "description": "Stop document collection in search phase after this many documents, 0 for unlimited."
        },
        "responseCompression": {
          "type": "string",
          "title": "Set gRPC compression codec to use for response message. If value is unset or invalid, falls back to uncompressed. Valid codecs: identity, gzip, lz4"
        },
        "highlight": {
          "$ref": "#/definitions/luceneserverHighlight",
          "title": "Specify how to highlight matched text"
        },
        "explain": {
          "type": "boolean",
          "title": "If Lucene explanation should be included in the response"
        },
        "inner_hits": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverInnerHit"
          },
          "title": "Search nested object fields for each hit"
        }
      }
    },
    "luceneserverSearchResponse": {
      "type": "object",
      "properties": {
        "diagnostics": {
          "$ref": "#/definitions/SearchResponseDiagnostics"
        },
        "hitTimeout": {
          "type": "boolean"
        },
        "totalHits": {
          "$ref": "#/definitions/luceneserverTotalHits"
        },
        "hits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchResponseHit"
          }
        },
        "searchState": {
          "$ref": "#/definitions/SearchResponseSearchState"
        },
        "facetResult": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacetResult"
          }
        },
        "profileResult": {
          "$ref": "#/definitions/luceneserverProfileResult",
          "title": "Detailed stats returned when profile=true in request"
        },
        "collectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "title": "Results from any additional document collectors"
        },
        "terminatedEarly": {
          "type": "boolean",
          "title": "If this query hit the terminateAfter threshold specified in the request"
        }
      }
    },
    "luceneserverSearcher": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "the version recorded in the commit that the reader opened.\nThis version is advanced every time a change is made with IndexWriter."
        },
        "numDocs": {
          "type": "integer",
          "format": "int32"
        },
        "segments": {
          "type": "string"
        },
        "staleAgeSeconds": {
          "type": "number",
          "format": "double"
        },
        "numSegments": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverSearcherVersion": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64"
        },
        "didRefresh": {
          "type": "boolean"
        }
      }
    },
    "luceneserverSelector": {
      "type": "string",
      "enum": [
        "MIN",
        "MAX",
        "MIDDLE_MIN",
        "MIDDLE_MAX"
      ],
      "default": "MIN",
      "title": "For multi valued fields, how to select which value is used for sorting"
    },
    "luceneserverSettingsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "mergeMaxMBPerSec": {
          "type": "number",
          "format": "double"
        },
        "nrtCachingDirectoryMaxMergeSizeMB": {
          "type": "number",
          "format": "double"
        },
        "nrtCachingDirectoryMaxSizeMB": {
          "type": "number",
          "format": "double"
        },
        "concurrentMergeSchedulerMaxThreadCount": {
          "type": "integer",
          "format": "int32"
        },
        "concurrentMergeSchedulerMaxMergeCount": {
          "type": "integer",
          "format": "int32"
        },
        "indexSort": {
          "$ref": "#/definitions/luceneserverSortFields"
        },
        "indexVerbose": {
          "type": "boolean"
        },
        "indexMergeSchedulerAutoThrottle": {
          "type": "boolean"
        },
        "normsFormat": {
          "type": "string"
        },
        "directory": {
          "type": "string",
          "title": "Base Directory implementation to use (NRTCachingDirectory will wrap this) either one of the core implementations (FSDirectory, MMapDirectory, NIOFSDirectory, SimpleFSDirectory, RAMDirectory (for temporary indices!) or a fully qualified path to a Directory implementation that has a public constructor taking a single File argument default: FSDirectory"
        }
      },
      "title": "Input to settings"
    },
    "luceneserverSettingsResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      },
      "title": "Settings Response returned from Server"
    },
    "luceneserverSettingsV2Request": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        },
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Settings to merge into existing settings, or unset to get current settings"
        }
      }
    },
    "luceneserverSettingsV2Response": {
      "type": "object",
      "properties": {
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Current index settings, including default values"
        }
      }
    },
    "luceneserverSnapshotId": {
      "type": "object",
      "properties": {
        "indexGen": {
          "type": "string",
          "format": "int64"
        },
        "taxonomyGen": {
          "type": "string",
          "format": "int64"
        },
        "stateGen": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "luceneserverSortFields": {
      "type": "object",
      "properties": {
        "sortedFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSortType"
          }
        }
      },
      "title": "Fields to sort on either during index time or search time"
    },
    "luceneserverSortType": {
      "type": "object",
      "properties": {
        "fieldName": {
          "type": "string"
        },
        "selector": {
          "$ref": "#/definitions/luceneserverSelector"
        },
        "origin": {
          "$ref": "#/definitions/luceneserverPoint"
        },
        "missingLat": {
          "type": "boolean",
          "description": "Whether missing values should sort last instead of first.\nNote that this runs \\\"before\\\" reverse, so if you sort missing first and reverse=true then missing values will\nbe at the end."
        },
        "reverse": {
          "type": "boolean",
          "title": "Sort in reverse of the field's natural order"
        },
        "unit": {
          "type": "string",
          "title": "The unit used for the distance sort. Supported options are m, km and mi, default is m"
        }
      },
      "description": "\"The field to sort on. Pass \u003ccode\u003edocid\u003c/code\u003e for index order and \u003ccode\u003escore\u003c/code\u003e for relevance sort."
    },
    "luceneserverStartIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "mode": {
          "$ref": "#/definitions/luceneserverMode"
        },
        "primaryGen": {
          "type": "string",
          "format": "int64"
        },
        "primaryAddress": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        },
        "restore": {
          "$ref": "#/definitions/luceneserverRestoreIndex"
        },
        "primaryDiscoveryFile": {
          "type": "string",
          "title": "replica, location of discovery file containing primary host/port. Used if primaryAddress is empty. If port is specified in this request, it overrides the value in the file"
        }
      },
      "title": "Start the index"
    },
    "luceneserverStartIndexResponse": {
      "type": "object",
      "properties": {
        "maxDoc": {
          "type": "integer",
          "format": "int32"
        },
        "numDocs": {
          "type": "integer",
          "format": "int32"
        },
        "segments": {
          "type": "string"
        },
        "startTimeMS": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "luceneserverStartIndexV2Request": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "index name"
        }
      },
      "title": "Start the index using IndexStartConfig configuration"
    },
    "luceneserverStateRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverStateResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string"
        }
      }
    },
    "luceneserverStatsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverStatsResponse": {
      "type": "object",
      "properties": {
        "ord": {
          "type": "integer",
          "format": "int32"
        },
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "description": "The total number of docs in this index, including docs not yet flushed (still in the RAM buffer),\nnot counting deletions."
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "description": "*\nThe total number of docs in this index, including\ndocs not yet flushed (still in the RAM buffer), and\nincluding deletions. NOTE: buffered deletions\nare not counted.  If you really need these to be\ncounted you should call {@link IndexWriter#commit()} first."
        },
        "dirSize": {
          "type": "string",
          "format": "int64"
        },
        "state": {
          "type": "string"
        },
        "taxonomy": {
          "$ref": "#/definitions/luceneserverTaxonomy"
        },
        "searchers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSearcher"
          }
        },
        "currentSearcher": {
          "$ref": "#/definitions/luceneserverSearcher"
        }
      }
    },
    "luceneserverStopIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        }
      }
    },
    "luceneserverSuggestLocalSource": {
      "type": "object",
      "properties": {
        "localFile": {
          "type": "string",
          "description": "Local file (to the server) to read suggestions + weights from; format is weight U+001F suggestion U+001F payload,\none per line, with suggestion UTF-8 encoded. If this option is used then searcher, suggestField,\nweightField/Expression, payloadField should not be specified."
        },
        "hasContexts": {
          "type": "boolean"
        },
        "hasPayload": {
          "type": "boolean"
        },
        "hasMultiSearchText": {
          "type": "boolean"
        }
      }
    },
    "luceneserverSuggestLookupHighlight": {
      "type": "object",
      "properties": {
        "oneHighlight": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverOneHighlight"
          }
        }
      }
    },
    "luceneserverSuggestLookupRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string"
        },
        "suggestName": {
          "type": "string"
        },
        "text": {
          "type": "string"
        },
        "highlight": {
          "type": "boolean"
        },
        "allTermsRequired": {
          "type": "boolean"
        },
        "contexts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "luceneserverSuggestLookupResponse": {
      "type": "object",
      "properties": {
        "results": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverOneSuggestLookupResponse"
          }
        }
      }
    },
    "luceneserverSuggestNonLocalSource": {
      "type": "object",
      "properties": {
        "indexGen": {
          "type": "string",
          "format": "int64"
        },
        "version": {
          "type": "string",
          "format": "int64"
        },
        "snapshot": {
          "type": "string"
        },
        "suggestField": {
          "type": "string"
        },
        "weightField": {
          "type": "string"
        },
        "weightExpression": {
          "type": "string"
        },
        "payloadField": {
          "type": "string"
        },
        "contextField": {
          "type": "string"
        },
        "searchTextField": {
          "type": "string"
        }
      }
    },
    "luceneserverTaxonomy": {
      "type": "object",
      "properties": {
        "numOrds": {
          "type": "integer",
          "format": "int32"
        },
        "segments": {
          "type": "string"
        }
      }
    },
    "luceneserverTermInSetQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Field in the document to query."
        },
        "textTerms": {
          "$ref": "#/definitions/TermInSetQueryTextTerms",
          "description": "Text terms to search for."
        },
        "intTerms": {
          "$ref": "#/definitions/TermInSetQueryIntTerms",
          "description": "Int terms to search for."
        },
        "longTerms": {
          "$ref": "#/definitions/TermInSetQueryLongTerms",
          "description": "Long terms to search for."
        },
        "floatTerms": {
          "$ref": "#/definitions/TermInSetQueryFloatTerms",
          "description": "Float terms to search for."
        },
        "doubleTerms": {
          "$ref": "#/definitions/TermInSetQueryDoubleTerms",
          "description": "Double terms to search for."
        }
      },
      "description": "Specialization for a disjunction over many terms that behaves like a ConstantScoreQuery over a BooleanQuery containing only BooleanClause.Occur.SHOULD clauses. Only ONE of the types of terms needs to be provided - the one that matches the type of the field."
    },
    "luceneserverTermQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Field in the document to query."
        },
        "textValue": {
          "type": "string",
          "description": "TEXT FieldType term to search for."
        },
        "intValue": {
          "type": "integer",
          "format": "int32",
          "description": "INT FieldType term to search for."
        },
        "longValue": {
          "type": "string",
          "format": "int64",
          "description": "LONG FieldType term to search for."
        },
        "floatValue": {
          "type": "number",
          "format": "float",
          "description": "FLOAT FieldType term to search for."
        },
        "doubleValue": {
          "type": "number",
          "format": "double",
          "description": "DOUBLE FieldType term to search for."
        },
        "booleanValue": {
          "type": "boolean",
          "description": "BOOLEAN FieldType term to search for."
        }
      },
      "description": "A query that matches documents containing a term."
    },
    "luceneserverTermVectors": {
      "type": "string",
      "enum": [
        "NO_TERMVECTORS",
        "TERMS",
        "TERMS_POSITIONS",
        "TERMS_POSITIONS_OFFSETS",
        "TERMS_POSITIONS_OFFSETS_PAYLOADS"
      ],
      "default": "NO_TERMVECTORS",
      "description": "Whether/how term vectors should be indexed."
    },
    "luceneserverTermsCollector": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "description": "Use field values for terms."
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "description": "Use FacetScript definition to produce terms."
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of top terms to return."
        },
        "order": {
          "$ref": "#/definitions/luceneserverBucketOrder",
          "description": "How results Buckets should be ordered, defaults to descending Bucket _count."
        }
      },
      "description": "Definition of term aggregating collector."
    },
    "luceneserverTopHitsCollector": {
      "type": "object",
      "properties": {
        "startHit": {
          "type": "integer",
          "format": "int32",
          "description": "Offset for retrieval of top hits."
        },
        "topHits": {
          "type": "integer",
          "format": "int32",
          "description": "Total hits to collect, note that the number of hits returned is (topHits - startHit)."
        },
        "querySort": {
          "$ref": "#/definitions/luceneserverQuerySortField",
          "description": "When specified, collector does sort based collection. Otherwise, relevance score is used."
        },
        "retrieveFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Which fields to retrieve."
        },
        "explain": {
          "type": "boolean",
          "title": "If Lucene explanation should be included in the collector response"
        }
      },
      "description": "Definition of top hits based collector."
    },
    "luceneserverTotalHits": {
      "type": "object",
      "properties": {
        "relation": {
          "$ref": "#/definitions/TotalHitsRelation"
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "* The value of the total hit count. Must be interpreted in the context of * {#relation}."
        }
      }
    },
    "luceneserverTransferStatus": {
      "type": "object",
      "properties": {
        "Message": {
          "type": "string"
        },
        "Code": {
          "$ref": "#/definitions/luceneserverTransferStatusCode"
        }
      }
    },
    "luceneserverTransferStatusCode": {
      "type": "string",
      "enum": [
        "Unknown",
        "Done",
        "Failed",
        "Ongoing"
      ],
      "default": "Unknown"
    },
    "luceneserverVirtualField": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript"
        },
        "name": {
          "type": "string"
        }
      },
      "title": "Virtual field used during search"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    },
    "runtimeError": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "runtimeStreamError": {
      "type": "object",
      "properties": {
        "grpc_code": {
          "type": "integer",
          "format": "int32"
        },
        "http_code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "http_status": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "typeLatLng": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double",
          "description": "The latitude in degrees. It must be in the range [-90.0, +90.0]."
        },
        "longitude": {
          "type": "number",
          "format": "double",
          "description": "The longitude in degrees. It must be in the range [-180.0, +180.0]."
        }
      },
      "description": "An object representing a latitude/longitude pair. This is expressed as a pair\nof doubles representing degrees latitude and degrees longitude. Unless\nspecified otherwise, this must conform to the\n\u003ca href=\"http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf\"\u003eWGS84\nstandard\u003c/a\u003e. Values must be within normalized ranges."
    }
  }
}
