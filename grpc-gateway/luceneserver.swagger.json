{
  "swagger": "2.0",
  "info": {
    "title": "yelp/nrtsearch/luceneserver.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "LuceneServer"
    },
    {
      "name": "ReplicationServer"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/status/metrics": {
      "get": {
        "summary": "Get prometheus metrics",
        "operationId": "LuceneServer_metrics",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/add_documents": {
      "post": {
        "summary": "Adds a stream of Documents to an index. Changes are not durable until after the next successful @commit call.",
        "operationId": "LuceneServer_addDocuments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": " (streaming inputs)",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/backup_warming_queries": {
      "post": {
        "summary": "Backup warming queries for an index to S3",
        "operationId": "LuceneServer_backupWarmingQueries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverBackupWarmingQueriesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverBackupWarmingQueriesRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/commit": {
      "post": {
        "summary": "Commits all pending index data changes to durable storage",
        "operationId": "LuceneServer_commit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCommitResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCommitRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/create_index": {
      "post": {
        "summary": "Create an Index. Optionally, initial settings and live settings may be specified. The index is created\nin the stopped state, unless specified.",
        "operationId": "LuceneServer_createIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCreateIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCreateIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/create_snapshot": {
      "post": {
        "summary": "Creates a snapshot in the index, which is saved point-in-time view of the last commit\nin the index such that no files referenced by that snapshot will be deleted by ongoing\nindexing until the snapshot is released with @releaseSnapshot.  Note that this will\nreference the last commit, so be sure to call commit first if you have pending changes\nthat you'd like to be included in the snapshot.\nThis can be used for backup purposes, i.e. after creating the snapshot you can copy\nall referenced files to backup storage, and then release the snapshot once complete.\nTo restore the backup, just copy all the files back and restart the server.\nIt can also be used for transactional purposes, i.e. if you sometimes need to search a\nspecific snapshot instead of the current live index. Creating a snapshot is very fast\n(does not require any file copying), but over time it will consume extra disk space as\nold segments are merged in the index.  Be sure to release the snapshot once you're done.\nSnapshots survive shutdown and restart of the server.  Returns all protected filenames\nreferenced by this snapshot: these files will not change and will not be deleted until\nthe snapshot is released. This returns the directories and files referenced by the snapshot.",
        "operationId": "LuceneServer_createSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCreateSnapshotResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverCreateSnapshotRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/custom/{id}/{path}": {
      "post": {
        "summary": "Process request in a plugin which implements CustomRequestPlugin interface.",
        "operationId": "LuceneServer_custom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverCustomResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "ID defined for custom requests in a plugin",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "path",
            "description": "Custom path that is defined in a plugin that maps to a route",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Parameters that can be processed by the plugin at the specified path"
                }
              },
              "title": "Input to custom"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete": {
      "post": {
        "summary": "Delete documents from an index. Changes are not durable until after the next successful @commit call.",
        "operationId": "LuceneServer_delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_all": {
      "post": {
        "summary": "Delete all documents for index. Changes are not durable until after the next successful @commit call.",
        "operationId": "LuceneServer_deleteAll",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteAllDocumentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteAllDocumentsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_by_query": {
      "post": {
        "summary": "Delete documents matching a query from an index. Changes are not durable until after the next successful\n@commit call.",
        "operationId": "LuceneServer_deleteByQuery",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverAddDocumentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteByQueryRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/delete_index": {
      "post": {
        "summary": "Delete index and all of its local data",
        "operationId": "LuceneServer_deleteIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverDeleteIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/force_merge": {
      "post": {
        "summary": "Forces merge policy to merge segments until there are \u003c= maxNumSegments. The actual\nmerges to be executed are determined by the MergePolicy. This call will merge those\nsegments present in the index when the call started. If other threads are still\nadding documents and flushing segments, those newly created segments will not be\nmerged unless you call forceMerge again.",
        "operationId": "LuceneServer_forceMerge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/force_merge_deletes": {
      "post": {
        "summary": "Forces merging of all segments that have deleted documents. The actual merges to be\nexecuted are determined by the MergePolicy. For example, the default TieredMergePolicy\nwill only pick a segment if the percentage of deleted docs is over 10%.\nThis method first flushes a new segment (if there are indexed documents), and applies\nall buffered deletes.",
        "operationId": "LuceneServer_forceMergeDeletes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeDeletesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverForceMergeDeletesRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/get_all_snapshot_index_gen/{indexName}": {
      "get": {
        "summary": "Gets all unreleased index gens of snapshots previously created with @createSnapshot",
        "operationId": "LuceneServer_getAllSnapshotIndexGen",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverGetAllSnapshotGenResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Name of the index to get snapshot gens",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/global_state": {
      "post": {
        "summary": "Get the global state of the cluster",
        "operationId": "LuceneServer_globalState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverGlobalStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverGlobalStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/index_state": {
      "post": {
        "summary": "Gets the state information for an index, includes settings, live_settings, search schema",
        "operationId": "LuceneServer_indexState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverIndexStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverIndexStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/index_state/{indexName}": {
      "get": {
        "summary": "Gets the state information for an index, includes settings, live_settings, search schema",
        "operationId": "LuceneServer_indexState2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverIndexStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Index name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/indices": {
      "get": {
        "summary": "Get information for all created indices",
        "operationId": "LuceneServer_indices",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverIndicesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/live_settings": {
      "post": {
        "summary": "Change live settings for an index. These settings may be changed while the index is started. Pass no\nsettings changes to retrieve current live settings.",
        "operationId": "LuceneServer_liveSettings",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/node_info": {
      "get": {
        "summary": "Get information about this node",
        "operationId": "LuceneServer_nodeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverNodeInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/ready": {
      "get": {
        "summary": "Checks if a node is ready to receive traffic by checking if all the indices configured to be started\nare started. Can specify comma-separated list of index names to only check specific indices if needed.",
        "operationId": "LuceneServer_ready",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexNames",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/ready/{indexNames}": {
      "get": {
        "summary": "Checks if a node is ready to receive traffic by checking if all the indices configured to be started\nare started. Can specify comma-separated list of index names to only check specific indices if needed.",
        "operationId": "LuceneServer_ready2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexNames",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/refresh": {
      "post": {
        "summary": "Refresh the latest searcher for an index",
        "operationId": "LuceneServer_refresh",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverRefreshResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverRefreshRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/register_fields": {
      "post": {
        "summary": "Adds one or more fields. Fields must be registered before they can be added in a document (via @addDocument).\nPass a list of Fields and an indexName. Any number of fields may be registered in a single request,\nand once a field is registered it cannot be changed (write-once).\nThis returns the full set of fields currently registered.",
        "operationId": "LuceneServer_registerFields",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/release_snapshot": {
      "post": {
        "summary": "Releases a snapshot previously created with @createSnapshot.",
        "operationId": "LuceneServer_releaseSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverReleaseSnapshotResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverReleaseSnapshotRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/reload_state": {
      "post": {
        "summary": "Reload state from the backend. When run on replicas, this processes state changes made by the primary.\nNew indices are created/started, and existing indices state is updated as needed.",
        "operationId": "LuceneServer_reloadState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverReloadStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverReloadStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/search": {
      "post": {
        "summary": "Execute a search query against an index",
        "operationId": "LuceneServer_search",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSearchResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSearchRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/settings": {
      "post": {
        "summary": "Change offline settings for an index. The index must be in a stopped state to make settings changes.\nThis returns the currently set settings. Passing no settings changes retrieves the current settings.",
        "operationId": "LuceneServer_settings",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/start_index": {
      "post": {
        "summary": "Starts an index",
        "operationId": "LuceneServer_startIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/state": {
      "post": {
        "summary": "Gets the state of an index, includes settings, live_settings, search schema",
        "operationId": "LuceneServer_state",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStateRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/state/{indexName}": {
      "get": {
        "summary": "Gets the state of an index, includes settings, live_settings, search schema",
        "operationId": "LuceneServer_state2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStateResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Index name to retrieve state",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stats": {
      "post": {
        "summary": "Retrieve index statistics",
        "operationId": "LuceneServer_stats",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStatsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStatsRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stats/{indexName}": {
      "get": {
        "summary": "Retrieve index statistics",
        "operationId": "LuceneServer_stats2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStatsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Index name to retrieve stats",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/status": {
      "get": {
        "summary": "Basic healthcheck, successful if the server is running",
        "operationId": "LuceneServer_status",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverHealthCheckResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "check",
            "description": "Healthcheck request",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/stop_index": {
      "post": {
        "summary": "Stops an index",
        "operationId": "LuceneServer_stopIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverDummyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStopIndexRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v1/update_fields": {
      "post": {
        "summary": "Adds one or more fields to an index. The behavior is currently the same as registerFields.",
        "operationId": "LuceneServer_updateFields",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverFieldDefRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/live_settings": {
      "post": {
        "summary": "Change live settings for an index. These settings may be changed while the index is started. Pass no\nsettings changes to retrieve current live settings.",
        "operationId": "LuceneServer_liveSettingsV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsV2Request"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/live_settings/{indexName}": {
      "get": {
        "summary": "Change live settings for an index. These settings may be changed while the index is started. Pass no\nsettings changes to retrieve current live settings.",
        "operationId": "LuceneServer_liveSettingsV22",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverLiveSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Name of index whose liveSettings are to be updated",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "liveSettings.maxRefreshSec",
            "description": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen), default: 1.0",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.minRefreshSec",
            "description": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen),\ndefault: 0.05",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.maxSearcherAgeSec",
            "description": "Non-current searchers older than this are pruned, default: 60.0",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.indexRamBufferSizeMB",
            "description": "Size (in MB) of IndexWriter's RAM buffer, default: 16.0",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.addDocumentsMaxBufferLen",
            "description": "Max number of documents to add at a time, default: 100",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.sliceMaxDocs",
            "description": "Maximum number of documents allowed in a parallel search slice, default: 250,000",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.sliceMaxSegments",
            "description": "Maximum number of segments allowed in a parallel search slice, default: 5",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.virtualShards",
            "description": "Number of virtual shards to use for this index, default: 1",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.maxMergedSegmentMB",
            "description": "Maximum sized segment to produce during normal merging, default: 5GB",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.segmentsPerTier",
            "description": "Number of segments per tier used by TieredMergePolicy, default: 10",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.defaultSearchTimeoutSec",
            "description": "Timeout value to used when not specified in the search request, or 0 for no timeout, default: 0",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "liveSettings.defaultSearchTimeoutCheckEvery",
            "description": "Timeout check every value to use when not specified in the search request, or 0 for none, default: 0",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.defaultTerminateAfter",
            "description": "Terminate after value to use when not specified in the search request, or 0 for none, default: 0",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.maxMergePreCopyDurationSec",
            "description": "Merge precopy would be stopped after this time, or 0 for no checks, default: 0",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "liveSettings.verboseMetrics",
            "description": "Collect and publish additional index metrics, which may be more expensive in terms of volume, memory\nand/or compute, default: false",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "liveSettings.parallelFetchByField",
            "description": "If fetch parallelism should be done by groups of fields instead of document, default: false",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "liveSettings.parallelFetchChunkSize",
            "description": "The number of documents/fields per parallel fetch task, default: 50",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "liveSettings.defaultTerminateAfterMaxRecallCount",
            "description": "Terminate after max recall count value to use when not specified in the search request, or 0 for none, default: 0",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "local",
            "description": "When set to true, live settings changes are only applied to the local node. These changes are ephemeral,\nso will not persist through a restart. Also, the live settings returned in the response will contain the\nlocal overrides only when this flag is true.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/search": {
      "post": {
        "summary": "Execute a search query against an index. Return response as an Any gRPC message. Useful if the client does\nnot need to process the response and wants to avoid some deserialization work.",
        "operationId": "LuceneServer_searchV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/protobufAny"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSearchRequest"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/settings": {
      "post": {
        "summary": "Change offline settings for an index. The index must be in a stopped state to make settings changes.\nThis returns the currently set settings. Passing no settings changes retrieves the current settings.",
        "operationId": "LuceneServer_settingsV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsV2Request"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/settings/{indexName}": {
      "get": {
        "summary": "Change offline settings for an index. The index must be in a stopped state to make settings changes.\nThis returns the currently set settings. Passing no settings changes retrieves the current settings.",
        "operationId": "LuceneServer_settingsV22",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverSettingsV2Response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "indexName",
            "description": "Index name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "settings.nrtCachingDirectoryMaxMergeSizeMB",
            "description": "Largest merged segment size to cache in RAMDirectory, default: 5.0MB",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "settings.nrtCachingDirectoryMaxSizeMB",
            "description": "Largest overall size for all files cached in NRTCachingDirectory, default: 60.0MB",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "settings.concurrentMergeSchedulerMaxThreadCount",
            "description": "How many merge threads to allow at once",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "settings.concurrentMergeSchedulerMaxMergeCount",
            "description": "Maximum backlog of pending merges before indexing threads are stalled",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "settings.indexMergeSchedulerAutoThrottle",
            "description": "Turn on/off the merge scheduler's auto throttling, default: off",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "settings.directory",
            "description": "Base Directory implementation to use either one of the core implementations\n(FSDirectory, MMapDirectory, NIOFSDirectory, or a fully qualified path to a Directory\nimplementation that has a public constructor taking a single File argument default: FSDirectory.\nThis implementation will be wrapped by NRTCachingDirectory, if enabled and not using MMappedDirectory.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    },
    "/v2/start_index": {
      "post": {
        "summary": "Starts an index based on configuration in IndexStartConfig",
        "operationId": "LuceneServer_startIndexV2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/luceneserverStartIndexV2Request"
            }
          }
        ],
        "tags": [
          "LuceneServer"
        ]
      }
    }
  },
  "definitions": {
    "AddDocumentRequestMultiValuedField": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of values for this field"
        },
        "faceHierarchyPaths": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacetHierarchyPath"
          },
          "title": "Facet paths/hierarchy to bucket these values by, if indexed field is of type Facet.HIERARCHY"
        }
      },
      "description": "Wrapper object to represent each field as a multivalued field."
    },
    "BooleanClauseOccur": {
      "type": "string",
      "enum": [
        "SHOULD",
        "MUST",
        "FILTER",
        "MUST_NOT"
      ],
      "default": "SHOULD",
      "description": "Defines how clauses may occur in matching documents. This will always be SHOULD by default."
    },
    "BucketOrderOrderType": {
      "type": "string",
      "enum": [
        "DESC",
        "ASC"
      ],
      "default": "DESC",
      "title": "Sorting order type"
    },
    "BucketResultBucket": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "title": "Bucket key"
        },
        "count": {
          "type": "integer",
          "format": "int32",
          "title": "Bucket item count"
        },
        "nestedCollectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "title": "Nested collector results for sub-aggregations of this bucket"
        }
      }
    },
    "DiagnosticsVectorDiagnostics": {
      "type": "object",
      "properties": {
        "searchTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time to do kNN search"
        },
        "totalHits": {
          "$ref": "#/definitions/luceneserverTotalHits",
          "title": "Total hits from kNN execution"
        }
      },
      "title": "Diagnostic info related kNN vector search queries"
    },
    "FieldValueVector": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "title": "Float vector value"
        },
        "bytesValue": {
          "type": "string",
          "format": "byte",
          "title": "Byte vector value"
        }
      }
    },
    "FuzzyParamsAutoFuzziness": {
      "type": "object",
      "properties": {
        "low": {
          "type": "integer",
          "format": "int32",
          "title": "Optional low distance argument"
        },
        "high": {
          "type": "integer",
          "format": "int32",
          "title": "Optional high distance argument"
        }
      },
      "title": "Optional low and high values for auto fuzziness. Defaults to low: 3 and high: 6 if both are unset.\nValid values are low \u003e= 0 and low \u003c high"
    },
    "HighlightSettings": {
      "type": "object",
      "properties": {
        "highlighterType": {
          "$ref": "#/definitions/luceneserverHighlightType",
          "description": "Specify type of highlighter to use. Ignored right now in nrtsearch."
        },
        "preTags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Used along with post_tags to specify how to wrap the highlighted text"
        },
        "postTags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Used along with pre_tags to specify how to wrap the highlighted text"
        },
        "fragmentSize": {
          "type": "integer",
          "format": "int64",
          "description": "Number of characters in highlighted fragment, 100 by default. Set it to be 0 to fetch the entire field."
        },
        "maxNumberOfFragments": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum number of highlight fragments to return, 5 by default. If set to 0 returns entire text as a single\nfragment ignoring fragment_size."
        },
        "highlightQuery": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Specify a query here if highlighting is desired against a different query than the search query"
        },
        "fieldMatch": {
          "type": "boolean",
          "title": "Set to true to highlight fields only if specified in the search query"
        },
        "scoreOrdered": {
          "type": "boolean",
          "title": "Sorts highlighted fragments by score when set to true. By default, fragments will be output in the order\nthey appear in the field. (Default is true)"
        },
        "fragmenter": {
          "type": "string",
          "description": "Select Fragmenter between span (default) and simple. This is only applicable for plain highlighters."
        },
        "discreteMultivalue": {
          "type": "boolean",
          "title": "Let the fragment builder respect the multivalue fields. Each fragment won't cross multiple value fields\nif set true. (Default is false)"
        },
        "customHighlighterName": {
          "type": "string",
          "description": "When highlighter_type is CUSTOM, use this string identifier to specify the highlighter. It is ignored for\nany other highlighter_types."
        },
        "customHighlighterParams": {
          "type": "object",
          "description": "Optional Custom parameters for custom highlighters. If a field overriding is present, the global setting\nwill be omitted for this field, and no merge will happen."
        },
        "boundaryScanner": {
          "type": "string",
          "description": "Define the boundary decision when creating fragments. Options are \"simple\" (default in fast vector\nhighlighter), \"word\" or \"sentence\"."
        },
        "boundaryChars": {
          "type": "string",
          "title": "Terminating chars when using \"simple\" boundary_scanner. The default is \".,!? \\t\\n\""
        },
        "boundaryMaxScan": {
          "type": "integer",
          "format": "int64",
          "description": "Number of chars to scan before finding the boundary_chars if using \"simple\" boundary scanner; If\n\"boundary_chars\" is not found after max scan, fragments will start/end at the original place. Default is 20."
        },
        "boundaryScannerLocale": {
          "type": "string",
          "description": "Locale used in boundary scanner when using \"word\" or \"sentence\" boundary_scanner. Examples: \"en-US\", \"ch-ZH\"."
        },
        "topBoostOnly": {
          "type": "boolean",
          "description": "Only highlight the top matched phrases (with the highest boost value) per fragment. By default, it is false."
        }
      }
    },
    "HitCompositeFieldValue": {
      "type": "object",
      "properties": {
        "fieldValue": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/HitFieldValue"
          },
          "title": "Field values"
        }
      },
      "title": "Field with multiple values"
    },
    "HitFieldValue": {
      "type": "object",
      "properties": {
        "textValue": {
          "type": "string",
          "title": "Value for ATOM and TEXT FieldType"
        },
        "booleanValue": {
          "type": "boolean",
          "title": "Value for BOOLEAN FieldType"
        },
        "intValue": {
          "type": "integer",
          "format": "int32",
          "title": "Value for INT FieldType"
        },
        "longValue": {
          "type": "string",
          "format": "int64",
          "title": "Value for LONG and DATE_TIME (as milliseconds since epoch in UTC zone) FieldType"
        },
        "floatValue": {
          "type": "number",
          "format": "float",
          "title": "Value for FLOAT FieldType"
        },
        "doubleValue": {
          "type": "number",
          "format": "double",
          "title": "Value for DOUBLE FieldType"
        },
        "latLngValue": {
          "$ref": "#/definitions/typeLatLng",
          "title": "Value for LAT_LON FieldType"
        },
        "structValue": {
          "type": "object",
          "title": "Value for structured data"
        },
        "vectorValue": {
          "$ref": "#/definitions/FieldValueVector",
          "title": "Value for VECTOR FieldType"
        },
        "listValue": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "title": "List of values"
        }
      },
      "title": "Field value for a hit"
    },
    "HitHighlights": {
      "type": "object",
      "properties": {
        "fragments": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Highlighted text fragments"
        }
      },
      "title": "Highlighted text result"
    },
    "MatchPhraseQueryZeroTerms": {
      "type": "string",
      "enum": [
        "NONE_ZERO_TERMS",
        "ALL_ZERO_TERMS"
      ],
      "default": "NONE_ZERO_TERMS",
      "description": "Zero Terms options when analyzer removes all tokens.\n\n - NONE_ZERO_TERMS: No documents are returned if the analyzer removes all tokens.\n - ALL_ZERO_TERMS: All documents are returned if the analyzer removes all tokens."
    },
    "MultiFunctionScoreQueryBoostMode": {
      "type": "string",
      "enum": [
        "BOOST_MODE_MULTIPLY",
        "BOOST_MODE_SUM",
        "BOOST_MODE_REPLACE"
      ],
      "default": "BOOST_MODE_MULTIPLY",
      "description": "- BOOST_MODE_MULTIPLY: Multiply scores together\n - BOOST_MODE_SUM: Add scores together\n - BOOST_MODE_REPLACE: Ignore the query score, and use the function score only",
      "title": "How to combine final function score with query score"
    },
    "MultiFunctionScoreQueryDecayFunction": {
      "type": "object",
      "properties": {
        "fieldName": {
          "type": "string",
          "title": "Document field name to use"
        },
        "decayType": {
          "$ref": "#/definitions/MultiFunctionScoreQueryDecayType",
          "title": "Type of decay function to apply"
        },
        "geoPoint": {
          "$ref": "#/definitions/typeLatLng"
        },
        "scale": {
          "type": "string",
          "title": "Currently only distance based scale and offset units are supported\nDistance from origin + offset at which computed score will be equal to decay. Scale should be distance,\nunit (m, km, mi) with space is optional. Default unit will be meters. Ex: \"10\", \"15 km\", \"5 m\", \"7 mi\""
        },
        "offset": {
          "type": "string",
          "title": "Compute decay function for docs with a distance greater than offset, will be 0.0 if none is set. Offset\nshould be distance, unit (m, km, mi) with space is optional. Default unit will be meters.\nEx: \"10\", \"15 km\", \"5 m\", \"7 mi\""
        },
        "decay": {
          "type": "number",
          "format": "float",
          "title": "Defines decay rate for scoring. Should be between (0, 1)"
        }
      },
      "title": "Apply decay function to docs"
    },
    "MultiFunctionScoreQueryDecayType": {
      "type": "string",
      "enum": [
        "DECAY_TYPE_EXPONENTIAL",
        "DECAY_TYPE_LINEAR",
        "DECAY_TYPE_GUASSIAN"
      ],
      "default": "DECAY_TYPE_EXPONENTIAL",
      "description": "- DECAY_TYPE_EXPONENTIAL: Exponential decay function\n - DECAY_TYPE_LINEAR: Linear decay function\n - DECAY_TYPE_GUASSIAN: Gaussian decay function",
      "title": "Decay function types"
    },
    "MultiFunctionScoreQueryFilterFunction": {
      "type": "object",
      "properties": {
        "filter": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Apply function only to docs that pass this filter, match all if not specified"
        },
        "weight": {
          "type": "number",
          "format": "float",
          "title": "Weight to multiply with function score, 1.0 if not specified"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Produce score with score script definition"
        },
        "decayFunction": {
          "$ref": "#/definitions/MultiFunctionScoreQueryDecayFunction",
          "title": "Produce score with a decay function"
        }
      },
      "title": "Function to produce a weighted value"
    },
    "MultiFunctionScoreQueryFunctionScoreMode": {
      "type": "string",
      "enum": [
        "SCORE_MODE_MULTIPLY",
        "SCORE_MODE_SUM"
      ],
      "default": "SCORE_MODE_MULTIPLY",
      "description": "- SCORE_MODE_MULTIPLY: Multiply weighted function scores together\n - SCORE_MODE_SUM: Add weighted function scores together",
      "title": "How to combine multiple function scores to produce a final function score"
    },
    "MultiMatchQueryMatchType": {
      "type": "string",
      "enum": [
        "BEST_FIELDS",
        "PHRASE_PREFIX",
        "CROSS_FIELDS"
      ],
      "default": "BEST_FIELDS",
      "description": "- BEST_FIELDS: Finds documents which match any field, but uses the _score from the best field\n - PHRASE_PREFIX: Runs a MatchPhrasePrefixQuery query on each field and uses the _score from the best field\n - CROSS_FIELDS: Finds documents that match across multiple fields, as if they were a single field",
      "title": "Type defining the execution behavior of the match"
    },
    "NestedQueryScoreMode": {
      "type": "string",
      "enum": [
        "NONE",
        "AVG",
        "MAX",
        "MIN",
        "SUM"
      ],
      "default": "NONE",
      "title": "How child documents score affects final score"
    },
    "ProfileResultAdditionalCollectorStats": {
      "type": "object",
      "properties": {
        "collectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Sum of all collection time"
        }
      },
      "title": "Stats for aggregating collector"
    },
    "ProfileResultCollectorStats": {
      "type": "object",
      "properties": {
        "terminated": {
          "type": "boolean",
          "title": "If collection for this index slice was terminated early, such as by a timeout"
        },
        "segmentStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProfileResultSegmentStats"
          },
          "title": "Stats for each collector segment"
        },
        "totalCollectedCount": {
          "type": "integer",
          "format": "int32",
          "title": "Total docs collected by this collector"
        },
        "totalCollectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Sum of all segment collection time"
        },
        "additionalCollectorStats": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ProfileResultAdditionalCollectorStats"
          },
          "title": "Stats for additional collection operations"
        }
      },
      "title": "Stats for parallel search collector"
    },
    "ProfileResultSearchStats": {
      "type": "object",
      "properties": {
        "totalCollectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Total time for all document collection"
        },
        "totalReduceTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Total time to reduce results from all parallel search slices"
        },
        "collectorStats": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProfileResultCollectorStats"
          },
          "title": "Stats for each collector"
        }
      },
      "title": "Stats for search phase"
    },
    "ProfileResultSegmentStats": {
      "type": "object",
      "properties": {
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "title": "Total docs in segment"
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Total live docs in segment"
        },
        "collectedCount": {
          "type": "integer",
          "format": "int32",
          "title": "How many docs were collected"
        },
        "relativeStartTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Start time of segment processing in relation to the start of the search phase"
        },
        "collectTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Collection duration"
        }
      },
      "title": "Stats for a single collector segment"
    },
    "ScriptParamFloatVectorValue": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "title": "Float vector value"
        }
      },
      "title": "Float vector parameter value"
    },
    "ScriptParamListValue": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ScriptParamValue"
          },
          "title": "Parameter values list"
        }
      },
      "title": "List parameter value"
    },
    "ScriptParamNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "title": "Null parameter value"
    },
    "ScriptParamStructValue": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ScriptParamValue"
          },
          "title": "Parameter values map"
        }
      },
      "title": "Map parameter value"
    },
    "ScriptParamValue": {
      "type": "object",
      "properties": {
        "textValue": {
          "type": "string"
        },
        "booleanValue": {
          "type": "boolean"
        },
        "intValue": {
          "type": "integer",
          "format": "int32"
        },
        "longValue": {
          "type": "string",
          "format": "int64"
        },
        "floatValue": {
          "type": "number",
          "format": "float"
        },
        "doubleValue": {
          "type": "number",
          "format": "double"
        },
        "nullValue": {
          "$ref": "#/definitions/ScriptParamNullValue"
        },
        "listValue": {
          "$ref": "#/definitions/ScriptParamListValue"
        },
        "structValue": {
          "$ref": "#/definitions/ScriptParamStructValue"
        },
        "floatVectorValue": {
          "$ref": "#/definitions/ScriptParamFloatVectorValue"
        }
      },
      "title": "Script parameter entry"
    },
    "SearchResponseDiagnostics": {
      "type": "object",
      "properties": {
        "parsedQuery": {
          "type": "string",
          "title": "Query debug has been moved to ProfileResult"
        },
        "rewrittenQuery": {
          "type": "string"
        },
        "drillDownQuery": {
          "type": "string"
        },
        "firstPassSearchTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time for initial recall and ranking"
        },
        "highlightTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time for highlighting"
        },
        "getFieldsTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time to fetch fields and perform other fetch tasks"
        },
        "newSnapshotSearcherOpenMs": {
          "type": "number",
          "format": "double",
          "title": "Time to open a new snapshot searcher"
        },
        "nrtWaitTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time waiting for nrt replication"
        },
        "facetTimeMs": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "double"
          },
          "title": "Time to execute facets"
        },
        "rescoreTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time to execute rescorers"
        },
        "rescorersTimeMs": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "double"
          },
          "title": "Time to execute each rescorer"
        },
        "innerHitsDiagnostics": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/SearchResponseDiagnostics"
          },
          "title": "Inner hits diagnostics"
        },
        "vectorDiagnostics": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DiagnosticsVectorDiagnostics"
          },
          "title": "Diagnostic info related to kNN vector search queries"
        },
        "initialDeadlineMs": {
          "type": "number",
          "format": "double",
          "title": "Amount of gRPC request deadline remaining at the start of search processing"
        },
        "loggingHitsTimeMs": {
          "type": "number",
          "format": "double",
          "title": "Time for logging hits"
        }
      }
    },
    "SearchResponseHit": {
      "type": "object",
      "properties": {
        "luceneDocId": {
          "type": "integer",
          "format": "int32",
          "title": "Lucene document id"
        },
        "score": {
          "type": "number",
          "format": "double",
          "title": "Document score"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitCompositeFieldValue"
          },
          "title": "Retrieved field data"
        },
        "sortedFields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitCompositeFieldValue"
          },
          "title": "When using query sorting, sorted field names to values"
        },
        "highlights": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HitHighlights"
          },
          "title": "Field name to highlighted text fragments"
        },
        "explain": {
          "type": "string",
          "title": "Lucene explanation of the hit"
        },
        "innerHits": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverHitsResult"
          },
          "title": "InnerHits for each hit"
        }
      },
      "title": "Message for query document hit"
    },
    "SearchResponseSearchState": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Query time"
        },
        "searcherVersion": {
          "type": "string",
          "format": "int64",
          "title": "Index searcher version"
        },
        "lastDocId": {
          "type": "integer",
          "format": "int32",
          "title": "replaced by lastHitInfo"
        },
        "lastFieldValues": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "replaced by lastHitInfo"
        },
        "lastScore": {
          "type": "number",
          "format": "float",
          "title": "replaced by lastHitInfo"
        },
        "lastHitInfo": {
          "$ref": "#/definitions/luceneserverLastHitInfo",
          "title": "Last hit info for search after"
        }
      },
      "title": "State for use in subsequent searches (search after)"
    },
    "TermInSetQueryDoubleTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          },
          "title": "DOUBLE field terms"
        }
      }
    },
    "TermInSetQueryFloatTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "title": "FLOAT field terms"
        }
      }
    },
    "TermInSetQueryIntTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          },
          "title": "INT field terms"
        }
      }
    },
    "TermInSetQueryLongTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          },
          "title": "LONG field terms"
        }
      }
    },
    "TermInSetQueryTextTerms": {
      "type": "object",
      "properties": {
        "terms": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "TEXT field terms"
        }
      }
    },
    "TotalHitsRelation": {
      "type": "string",
      "enum": [
        "EQUAL_TO",
        "GREATER_THAN_OR_EQUAL_TO"
      ],
      "default": "EQUAL_TO",
      "description": "- EQUAL_TO: The total hit count is equal to {@link TotalHits#value}\n - GREATER_THAN_OR_EQUAL_TO: The total hit count is greater than or equal to {@link TotalHits#value}",
      "title": "How the {TotalHits#value} should be interpreted"
    },
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "contentType": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest)\n        returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody)\n        returns (google.protobuf.Empty);\n\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "luceneserverAddDocumentRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AddDocumentRequestMultiValuedField"
          },
          "title": "Map of field name to a list of string values"
        }
      },
      "title": "Message representing a document to index"
    },
    "luceneserverAddDocumentResponse": {
      "type": "object",
      "properties": {
        "genId": {
          "type": "string",
          "title": "Lucene index sequence number after adding the documents"
        },
        "primaryId": {
          "type": "string",
          "title": "Unique identifier for the primary instance that processed the request"
        }
      },
      "title": "Response from Server for addDocument"
    },
    "luceneserverAddReplicaResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string",
          "title": "Returns \"ok\" string on success"
        }
      },
      "title": "Response from Server for addReplica"
    },
    "luceneserverAnalyzer": {
      "type": "object",
      "properties": {
        "predefined": {
          "type": "string",
          "title": "Analyzers predefined in Lucene, apart from standard and classic there are en.English, bn.Bengali,\neu.Basque, etc. (names derived from Lucene's analyzer class names)"
        },
        "custom": {
          "$ref": "#/definitions/luceneserverCustomAnalyzer",
          "title": "Custom analyzer"
        }
      },
      "title": "Analyzer definition"
    },
    "luceneserverBackupWarmingQueriesRequest": {
      "type": "object",
      "properties": {
        "index": {
          "type": "string",
          "title": "Index whose warming queries to backup"
        },
        "serviceName": {
          "type": "string",
          "title": "Remote storage namespace qualifier for service"
        },
        "numQueriesThreshold": {
          "type": "integer",
          "format": "int32",
          "title": "Optional; minimum # of queries required to backup warming queries"
        },
        "uptimeMinutesThreshold": {
          "type": "integer",
          "format": "int32",
          "title": "Optional; minimum # of minutes uptime to backup warming queries"
        }
      },
      "title": "Input to backupWarmingQueries"
    },
    "luceneserverBackupWarmingQueriesResponse": {
      "type": "object",
      "title": "Response from Server for backupWarmingQueries"
    },
    "luceneserverBooleanClause": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "The Query for the clause"
        },
        "occur": {
          "$ref": "#/definitions/BooleanClauseOccur",
          "description": "Specifies how this clause must occur in a matching document. SHOULD by default."
        }
      },
      "description": "A clause in a BooleanQuery."
    },
    "luceneserverBooleanQuery": {
      "type": "object",
      "properties": {
        "clauses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverBooleanClause"
          },
          "title": "Clauses for a boolean query"
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32",
          "title": "Minimum number of optional clauses that must match"
        }
      },
      "title": "A query that matches documents using boolean combinations of other queries"
    },
    "luceneserverBucketOrder": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "What to use for sorting. This can be _count for Bucket count, or the name of a nested collector that\nsupports ordering."
        },
        "order": {
          "$ref": "#/definitions/BucketOrderOrderType",
          "title": "Sorting order"
        }
      },
      "title": "Defines how Buckets should be ordered in BucketResult"
    },
    "luceneserverBucketResult": {
      "type": "object",
      "properties": {
        "buckets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/BucketResultBucket"
          },
          "title": "Buckets"
        },
        "totalBuckets": {
          "type": "integer",
          "format": "int32",
          "title": "Number of unique buckets, including those not in the buckets list"
        },
        "totalOtherCounts": {
          "type": "integer",
          "format": "int32",
          "title": "Number of other collected counts not represented in the buckets' counts"
        }
      },
      "title": "Results from bucketing collector"
    },
    "luceneserverCollector": {
      "type": "object",
      "properties": {
        "terms": {
          "$ref": "#/definitions/luceneserverTermsCollector",
          "title": "Collector for aggregating based on term values"
        },
        "pluginCollector": {
          "$ref": "#/definitions/luceneserverPluginCollector"
        },
        "topHitsCollector": {
          "$ref": "#/definitions/luceneserverTopHitsCollector",
          "title": "Collector for getting top hits based on score or sorting"
        },
        "filter": {
          "$ref": "#/definitions/luceneserverFilterCollector",
          "title": "Collector that filters documents to nested collectors"
        },
        "max": {
          "$ref": "#/definitions/luceneserverMaxCollector",
          "title": "Collector for finding a max double value from collected documents"
        },
        "min": {
          "$ref": "#/definitions/luceneserverMinCollector",
          "title": "Collector for finding a min double value from collected documents"
        },
        "nestedCollectors": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollector"
          },
          "title": "Nested collectors that define sub-aggregations per bucket, supported by bucket based collectors"
        }
      },
      "title": "Definition of additional document collector"
    },
    "luceneserverCollectorResult": {
      "type": "object",
      "properties": {
        "bucketResult": {
          "$ref": "#/definitions/luceneserverBucketResult",
          "title": "Result of collector that produces buckets and counts"
        },
        "anyResult": {
          "$ref": "#/definitions/protobufAny",
          "title": "Flexible collector result for additional document collectors"
        },
        "hitsResult": {
          "$ref": "#/definitions/luceneserverHitsResult",
          "title": "Result of collector that returns document hits"
        },
        "filterResult": {
          "$ref": "#/definitions/luceneserverFilterResult",
          "title": "Result of collector that filters documents"
        },
        "doubleResult": {
          "type": "number",
          "format": "double",
          "title": "Result of collector that produces a single double value"
        }
      },
      "title": "Result of aggregating collector"
    },
    "luceneserverCommitRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to commit"
        }
      },
      "title": "Input to commit"
    },
    "luceneserverCommitResponse": {
      "type": "object",
      "properties": {
        "gen": {
          "type": "string",
          "format": "int64",
          "description": "Sequence number of the last operation in the commit. All sequence numbers less than this value\nwill be reflected in the commit, and all others will not."
        },
        "primaryId": {
          "type": "string",
          "title": "Unique identifier for the primary instance that processed the request"
        }
      },
      "title": "Response from Server for commit"
    },
    "luceneserverCompletionQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Name of the field in the document to query, must be a SuggestField"
        },
        "queryType": {
          "$ref": "#/definitions/luceneserverCompletionQueryType",
          "title": "Completion query type, used when constructing the lucene completion query"
        },
        "text": {
          "type": "string",
          "title": "Completion text to be used in completion query"
        },
        "contexts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of contexts to filter by. Each result will have at least one of the contexts specified"
        }
      },
      "title": "A query used for suggest completion"
    },
    "luceneserverCompletionQueryType": {
      "type": "string",
      "enum": [
        "PREFIX_QUERY",
        "FUZZY_QUERY"
      ],
      "default": "PREFIX_QUERY",
      "description": "- PREFIX_QUERY: PrefixCompletionQuery within ContextCompletionQuery\n - FUZZY_QUERY: FuzzyCompletionQuery within ContextCompletionQuery",
      "title": "Type of completion query"
    },
    "luceneserverConditionalTokenFilter": {
      "type": "object",
      "properties": {
        "condition": {
          "$ref": "#/definitions/luceneserverNameAndParams",
          "title": "Condition to apply the token filter"
        },
        "tokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          },
          "title": "Token filters to apply if the condition is met"
        }
      },
      "title": "Used to specify a conditional token filter"
    },
    "luceneserverConstantScoreQuery": {
      "type": "object",
      "properties": {
        "filter": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Query to determine matching documents"
        }
      },
      "title": "Query that produces a score of 1.0 (modifiable by query boost value) for documents that match the filter query"
    },
    "luceneserverCopyState": {
      "type": "object",
      "properties": {
        "infoBytesLength": {
          "type": "integer",
          "format": "int32",
          "title": "InfoBytes length"
        },
        "infoBytes": {
          "type": "string",
          "format": "byte",
          "title": "InfoBytes"
        },
        "gen": {
          "type": "string",
          "format": "int64",
          "title": "Index generation"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "Index version"
        },
        "filesMetadata": {
          "$ref": "#/definitions/luceneserverFilesMetadata",
          "title": "Index file metadata"
        },
        "completedMergeFilesSize": {
          "type": "integer",
          "format": "int32",
          "title": "Completed merged files size"
        },
        "completedMergeFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Completed merged files"
        },
        "primaryGen": {
          "type": "string",
          "format": "int64",
          "title": "Primary generation"
        }
      },
      "title": "Holds incRef'd file level details for one point-in-time segment infos on the primary node"
    },
    "luceneserverCreateIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of the index to be created. [a-zA-Z0-9_-]+"
        },
        "existsWithId": {
          "type": "string",
          "description": "Set if state/data already exists in the data backend. Provides the yyyyMMddHHmmssSSS formatted date-time\nstring to identify and load the index data."
        },
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Optional initial index settings"
        },
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Optional initial index live settings"
        },
        "fields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          },
          "title": "Optional initial index fields"
        },
        "start": {
          "type": "boolean",
          "title": "If this index should also be started, using IndexStartConfig configuration"
        }
      },
      "title": "Input to createIndex"
    },
    "luceneserverCreateIndexResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string",
          "title": "Message confirming creation of the index"
        }
      },
      "title": "Response from Server to createIndex"
    },
    "luceneserverCreateSnapshotRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of the index to snapshot"
        },
        "openSearcher": {
          "type": "boolean",
          "title": "Pass true if you intend to do searches against this snapshot, by passing searcher: {snapshot: X} to @search"
        }
      },
      "description": "Creates a snapshot in the index, which is saved point-in-time view of the last commit in the\nindex such that no files referenced by that snapshot will be deleted by ongoing indexing until\nthe snapshot is released with @releaseSnapshot.  Note that this will reference the last commit,\nso be sure to call commit first if you have pending changes that you'd like to be included in\nthe snapshot.\u003cp\u003eThis can be used for backup purposes, i.e. after creating the snapshot you can\ncopy all referenced files to backup storage, and then release the snapshot once complete.\nTo restore the backup, just copy all the files back and restart the server.  It can also\nbe used for transactional purposes, i.e. if you sometimes need to search a specific snapshot\ninstead of the current live index.\u003cp\u003eCreating a snapshot is very fast (does not require any\nfile copying), but over time it will consume extra disk space as old segments are merged in\nthe index.  Be sure to release the snapshot once you're done.  Snapshots survive shutdown\nand restart of the server.  Returns all protected filenames referenced by this snapshot:\nthese files will not change and will not be deleted until the snapshot is released.\nThis returns the directories and files referenced by the snapshot."
    },
    "luceneserverCreateSnapshotResponse": {
      "type": "object",
      "properties": {
        "indexFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of index files referenced by this snapshot"
        },
        "taxonomyFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of taxonomy index files referenced by this snapshot"
        },
        "stateFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "List of state index files referenced by this snapshot"
        },
        "snapshotId": {
          "$ref": "#/definitions/luceneserverSnapshotId",
          "title": "Snapshot id"
        }
      },
      "title": "Response from Server for createSnapshot"
    },
    "luceneserverCustomAnalyzer": {
      "type": "object",
      "properties": {
        "charFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          },
          "title": "Specify a Lucene character filters (https://lucene.apache.org/core/9_12_0/core/org/apache/lucene/analysis/CharFilter.html)"
        },
        "tokenizer": {
          "$ref": "#/definitions/luceneserverNameAndParams",
          "title": "Specify a Lucene tokenizer (https://lucene.apache.org/core/9_12_0/core/org/apache/lucene/analysis/Tokenizer.html)"
        },
        "tokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNameAndParams"
          },
          "title": "Specify a Lucene token filter (https://lucene.apache.org/core/9_12_0/core/org/apache/lucene/analysis/TokenFilter.html)"
        },
        "conditionalTokenFilters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverConditionalTokenFilter"
          },
          "description": "TODO: this is not properly supported yet, the only impl requires a protected terms file."
        },
        "defaultMatchVersion": {
          "type": "string",
          "title": "Lucene version as LUCENE_X_Y_Z or X.Y.Z, LATEST by default"
        },
        "positionIncrementGap": {
          "$ref": "#/definitions/luceneserverIntObject",
          "title": "Must be \u003e= 0"
        },
        "offsetGap": {
          "$ref": "#/definitions/luceneserverIntObject",
          "title": "Must be \u003e= 0"
        }
      },
      "title": "Custom analyzer definition"
    },
    "luceneserverCustomResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "title": "Response from Server for custom"
    },
    "luceneserverDeleteAllDocumentsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to delete all documents from"
        }
      },
      "title": "Input to deleteAllDocuments"
    },
    "luceneserverDeleteAllDocumentsResponse": {
      "type": "object",
      "properties": {
        "genId": {
          "type": "string",
          "title": "Lucene index sequence number after deleting all documents"
        }
      },
      "title": "Response from Server for deleteAllDocuments"
    },
    "luceneserverDeleteByQueryRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to delete documents from"
        },
        "query": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverQuery"
          },
          "title": "Queries to match documents to be deleted"
        }
      },
      "title": "Input to deleteByQuery"
    },
    "luceneserverDeleteIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to delete"
        }
      },
      "title": "Input to deleteIndex"
    },
    "luceneserverDeleteIndexResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string",
          "title": "Returns \"ok\" string on success"
        }
      },
      "title": "Response from Server for deleteIndex"
    },
    "luceneserverDisjunctionMaxQuery": {
      "type": "object",
      "properties": {
        "disjuncts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverQuery"
          },
          "title": "A list of all the disjuncts to add"
        },
        "tieBreakerMultiplier": {
          "type": "number",
          "format": "float",
          "title": "The score of each non-maximum disjunct for a document is multiplied by this weight and added into the\nfinal score"
        }
      },
      "description": "A query that generates the union of documents produced by its subqueries, and that scores each document with the\nmaximum score for that document as produced by any subquery, plus a tie breaking increment for any additional\nmatching subqueries."
    },
    "luceneserverDummyResponse": {
      "type": "object",
      "properties": {
        "ok": {
          "type": "string",
          "title": "Returns \"ok\" string on success"
        }
      },
      "title": "Response with no content"
    },
    "luceneserverExactVectorQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "queryFloatVector": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "title": "Query vector for fields with the float element type"
        },
        "queryByteVector": {
          "type": "string",
          "format": "byte",
          "title": "Query vector for fields with the byte element type"
        }
      },
      "title": "A query that does a brute force search for documents with a vector most similar to the query vector"
    },
    "luceneserverExistsQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        }
      },
      "title": "A query that matches documents which contain a value for a field"
    },
    "luceneserverFacet": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "string",
          "title": "Dimension (field)"
        },
        "paths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Prefix path to facet 'under'"
        },
        "numericRange": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNumericRangeType"
          },
          "description": "Custom numeric ranges. Field must be indexed with facet=numericRange."
        },
        "useOrdsCache": {
          "type": "boolean",
          "title": "No longer used"
        },
        "labels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Specific facet labels to retrieve"
        },
        "topN": {
          "type": "integer",
          "format": "int32",
          "title": "How many top facets to return"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "FacetScript definition to use in place of index facet"
        },
        "sampleTopDocs": {
          "type": "integer",
          "format": "int32",
          "description": "Facet over the top N ranked documents, instead of all hits. Only works with field doc values."
        },
        "name": {
          "type": "string",
          "title": "Name for this facet"
        }
      },
      "title": "Facet request definition"
    },
    "luceneserverFacetHierarchyPath": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Facet path"
        }
      },
      "title": "Path for hierarchical facets"
    },
    "luceneserverFacetResult": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "string",
          "title": "Dimension that was requested"
        },
        "path": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Path whose children were requested"
        },
        "value": {
          "type": "number",
          "format": "double",
          "title": "Total value for this path (sum of all child counts, or sum of all child values), even those not included\nin the topN"
        },
        "labelValues": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverLabelAndValue"
          },
          "title": "Child counts"
        },
        "childCount": {
          "type": "string",
          "format": "int64",
          "title": "How many child labels were encountered"
        },
        "name": {
          "type": "string",
          "title": "Name for this facet"
        }
      },
      "title": "Result of facet collection"
    },
    "luceneserverFacetType": {
      "type": "string",
      "enum": [
        "NO_FACETS",
        "FLAT",
        "HIERARCHY",
        "NUMERIC_RANGE",
        "SORTED_SET_DOC_VALUES"
      ],
      "default": "NO_FACETS",
      "description": "- NO_FACETS: No facets are indexed\n - FLAT: Facets are indexed with no hierarchy\n - HIERARCHY: Facets are indexed and are hierarchical\n - NUMERIC_RANGE: Compute facet counts for custom numeric ranges\n - SORTED_SET_DOC_VALUES: Uses SortedSetDocValuesFacetCounts, which must be flat but don't require a taxonomy index",
      "title": "Whether/how facets should be indexed"
    },
    "luceneserverFetchTask": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of task, as registered by a FetchTaskPlugin"
        },
        "params": {
          "type": "object",
          "title": "Optional task parameters"
        }
      },
      "title": "Define additional task to perform in the fetch phase"
    },
    "luceneserverField": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of the field"
        },
        "type": {
          "$ref": "#/definitions/luceneserverFieldType",
          "title": "Type of the field"
        },
        "search": {
          "type": "boolean",
          "title": "True if the value should be available for searching (or numeric range searching, for a numeric fields)"
        },
        "store": {
          "type": "boolean",
          "title": "True if the value should be stored in the index"
        },
        "storeDocValues": {
          "type": "boolean",
          "title": "True if the value should be indexed into doc values"
        },
        "sort": {
          "type": "boolean",
          "title": "No longer used"
        },
        "tokenize": {
          "type": "boolean",
          "title": "No longer used"
        },
        "group": {
          "type": "boolean",
          "title": "No longer used"
        },
        "multiValued": {
          "type": "boolean",
          "title": "True if this field may have more than one value"
        },
        "highlight": {
          "type": "boolean",
          "title": "No longer used"
        },
        "omitNorms": {
          "type": "boolean",
          "title": "True if norms are omitted for text fields"
        },
        "dateTimeFormat": {
          "type": "string",
          "title": "Format string used to parse datetime fields, supported values are:\n    1) DateTimeFormatter format\n    2) \"epoch_millis\" (datetime value is epoch timestamp)\n    3) \"strict_date_optional_time\" (date with optional time in pattern of \"yyyy-MM-dd['T'HH:mm:ss[.SSS]]\")"
        },
        "postingsFormat": {
          "type": "string",
          "title": "Which PostingsFormat should be used to index this field, defaults to Lucene codec default"
        },
        "docValuesFormat": {
          "type": "string",
          "title": "Which DocValuesFormat should be used to index this field, defaults to Lucene codec default"
        },
        "indexOptions": {
          "$ref": "#/definitions/luceneserverIndexOptions",
          "title": "How the tokens should be indexed for text fields"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "The script definition defining a virtual field's value (only used with type=virtual)"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "title": "Analyzer to use for this field during indexing and searching, defaults to Lucene standard analyzer"
        },
        "indexAnalyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "title": "Analyzer to use for this field during indexing, if different from analyzer"
        },
        "searchAnalyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "title": "Analyzer to use for this field during searching, if different from analyzer"
        },
        "termVectors": {
          "$ref": "#/definitions/luceneserverTermVectors",
          "title": "Whether/how term vectors should be indexed"
        },
        "similarity": {
          "type": "string",
          "title": "Which Similarity implementation to use for this field, defaults to BM25Similarity"
        },
        "facet": {
          "$ref": "#/definitions/luceneserverFacetType",
          "title": "Whether/how facets should be indexed"
        },
        "facetIndexFieldName": {
          "type": "string",
          "title": "Which underlying Lucene index field is used to hold any indexed taxonomy or sorted set doc values facets,\ndefaults to '$_\u003cfield_name\u003e'"
        },
        "additionalProperties": {
          "type": "object",
          "title": "Additional info needed to configure field, used for CUSTOM types"
        },
        "similarityParams": {
          "type": "object",
          "title": "Parameters for similarity implementation"
        },
        "childFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          },
          "description": "Child fields accessible by dot notation. For standard fields, this indexes the same data as the parent field.\nFor object fields, this represents the subfields within the object."
        },
        "eagerGlobalOrdinals": {
          "type": "boolean",
          "description": "Compute facet global ordinals for this field up front, otherwise this is done lazily on first query.\nCurrently only for SORTED_SET_DOC_VALUES facet type."
        },
        "nestedDoc": {
          "type": "boolean",
          "title": "True if object data should be indexed as child documents"
        },
        "vectorDimensions": {
          "type": "integer",
          "format": "int32",
          "title": "Dimensions for vector field types"
        },
        "eagerFieldGlobalOrdinals": {
          "type": "boolean",
          "description": "If field based global ordinals should be built up front, otherwise this is done lazily on first access.\nCurrently only for fields with text doc values (TEXT/ATOM)."
        },
        "vectorSimilarity": {
          "type": "string",
          "title": "Similarity type for search enabled VECTOR fields. This is a required option when search=true.\nAccepts built in types:\n     'l2_norm'          : (1 / (1 + l2_norm(query, vector)^2))\n     'dot_product'      : Float vector: ((1 + dot_product(query, vector)) / 2) (all vectors must be unit length)\n                          Byte vector : 0.5 + (dot_product(query, vector) / (32768 * dims))\n                             (all vectors must have the same length)\n     'cosine'           : ((1 + cosine(query, vector)) / 2)\n     'normalized_cosine': Identical usage to 'cosine', but indexed and query vectors are automatically normalized\n                          to unit length. Original vector magnitude is available in the \u003cfield\u003e._magnitude field.\n     'max_inner_product': when \u003c 0 : 1 / (1 + -1 * max_inner_product(query, vector))\n                          when \u003e= 0: max_inner_product(query, vector) + 1"
        },
        "vectorIndexingOptions": {
          "$ref": "#/definitions/luceneserverVectorIndexingOptions",
          "description": "Indexing options for search enabled VECTOR field type. This is optional, defaulting to HNSW with m=16,\nef_construction=100 when not set."
        },
        "textDocValuesType": {
          "$ref": "#/definitions/luceneserverTextDocValuesType",
          "description": "Specify doc values type for TEXT/ATOM field types. This is optional, defaulting to SORTED when not set.\n Multivalued fields will always use SORTED_SET."
        },
        "vectorElementType": {
          "$ref": "#/definitions/luceneserverVectorElementType",
          "title": "Element type for vector field, defaulting to FLOAT when not set"
        },
        "positionIncrementGap": {
          "type": "integer",
          "format": "int32",
          "description": "Position increment gap for indexing multi valued TEXT fields. Must be \u003e= 0, defaulting to 100 when not set."
        },
        "ignoreAbove": {
          "type": "integer",
          "format": "int32",
          "title": "For arrays of strings, ignoreAbove will be applied for each array element separately and string elements longer\nthan ignore_above will not be indexed or stored. This option is useful for protecting against Lucenes\nterm byte-length limit of 32766"
        },
        "indexPrefixes": {
          "$ref": "#/definitions/luceneserverIndexPrefixes",
          "title": "IndexPrefixes when set for TEXT field"
        }
      },
      "title": "Definition of a field in an index"
    },
    "luceneserverFieldDefRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of index to add fields to"
        },
        "field": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverField"
          },
          "title": "List of fields to add"
        }
      },
      "title": "Input to registerFields"
    },
    "luceneserverFieldDefResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string",
          "title": "Json string of object containing all index fields (including newly added fields)"
        }
      },
      "title": "Response from Server for registerFields"
    },
    "luceneserverFieldType": {
      "type": "string",
      "enum": [
        "ATOM",
        "TEXT",
        "BOOLEAN",
        "LONG",
        "INT",
        "DOUBLE",
        "FLOAT",
        "LAT_LON",
        "DATE_TIME",
        "VIRTUAL",
        "INTERNAL",
        "CUSTOM",
        "_ID",
        "POLYGON",
        "OBJECT",
        "VECTOR",
        "CONTEXT_SUGGEST",
        "RUNTIME"
      ],
      "default": "ATOM",
      "description": "- ATOM: Text that's indexed as a single token, with DOCS_ONLY and omitting norms\n - TEXT: Text that's tokenized and indexed, with the index-time analyzer\n - BOOLEAN: Boolean value\n - LONG: Long value\n - INT: Int value\n - DOUBLE: Double value\n - FLOAT: Float value\n - LAT_LON: A latitude/longitude point\n - DATE_TIME: Date and optional time\n - VIRTUAL: Virtual field defined with a Script\n - INTERNAL: Internal field, not currently used\n - CUSTOM: Field type specified by name\n - _ID: Field type for document ID\n - POLYGON: Geojson defined polygon\n - OBJECT: Json object with child fields for each key\n - VECTOR: List of float values\n - CONTEXT_SUGGEST: Field used for contextual suggest fields\n - RUNTIME: Runtime fields",
      "title": "Type of a Field"
    },
    "luceneserverFileMetadata": {
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string",
          "title": "File name"
        },
        "len": {
          "type": "string",
          "format": "int64",
          "title": "File length"
        },
        "checksum": {
          "type": "string",
          "format": "int64",
          "title": "File checksum"
        },
        "headerLength": {
          "type": "integer",
          "format": "int32",
          "title": "File header length"
        },
        "header": {
          "type": "string",
          "format": "byte",
          "title": "File header"
        },
        "footerLength": {
          "type": "integer",
          "format": "int32",
          "title": "File footer length"
        },
        "footer": {
          "type": "string",
          "format": "byte",
          "title": "File footer"
        }
      },
      "title": "Metadata for a single index file"
    },
    "luceneserverFilesMetadata": {
      "type": "object",
      "properties": {
        "numFiles": {
          "type": "integer",
          "format": "int32"
        },
        "fileMetadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFileMetadata"
          }
        }
      },
      "title": "Metadata for multiple index files"
    },
    "luceneserverFilterCollector": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Only propagate documents that match the given query"
        },
        "setQuery": {
          "$ref": "#/definitions/luceneserverTermInSetQuery",
          "description": "Specialized implementation for set queries, checks if field doc values are in the provided set.\nThis can be useful for large set sizes with lower recall, where building the scorer would be expensive."
        }
      },
      "title": "Definition of filtering collector, there must be at least one nested collector specified in the Collector message"
    },
    "luceneserverFilterResult": {
      "type": "object",
      "properties": {
        "docCount": {
          "type": "integer",
          "format": "int32",
          "title": "Number of documents that passed the filter"
        },
        "nestedCollectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "title": "Results from nested collectors"
        }
      },
      "title": "Result from filter collector"
    },
    "luceneserverForceMergeDeletesRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name whose segments having deletes must be force merged"
        },
        "doWait": {
          "type": "boolean",
          "description": "If true, waits until the force merge is completed before returning a response. Otherwise starts force\nmerging in async and returns a response."
        }
      },
      "title": "Input to forceMergeDeletes"
    },
    "luceneserverForceMergeDeletesResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/luceneserverForceMergeDeletesResponseStatus",
          "title": "Status of force merge deletes"
        }
      },
      "title": "Response from Server for forceMergeDeletes"
    },
    "luceneserverForceMergeDeletesResponseStatus": {
      "type": "string",
      "enum": [
        "FORCE_MERGE_DELETES_COMPLETED",
        "FORCE_MERGE_DELETES_SUBMITTED"
      ],
      "default": "FORCE_MERGE_DELETES_COMPLETED",
      "title": "Status of force merge deletes"
    },
    "luceneserverForceMergeRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name whose segments must be force merged"
        },
        "maxNumSegments": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of segments after force merge"
        },
        "doWait": {
          "type": "boolean",
          "description": "If true, waits until the force merge is completed before returning a response. Otherwise starts force\nmerging in async and returns a response."
        }
      },
      "title": "Input to forceMerge"
    },
    "luceneserverForceMergeResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/luceneserverForceMergeResponseStatus",
          "title": "Status of force merge"
        }
      },
      "title": "Response from Server for forceMerge"
    },
    "luceneserverForceMergeResponseStatus": {
      "type": "string",
      "enum": [
        "FORCE_MERGE_COMPLETED",
        "FORCE_MERGE_SUBMITTED"
      ],
      "default": "FORCE_MERGE_COMPLETED",
      "title": "Status of force merge"
    },
    "luceneserverFunctionFilterQuery": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script definition to compute a custom document score"
        }
      },
      "title": "A query that retrieves all documents with a positive score calculated by the script"
    },
    "luceneserverFunctionScoreQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Input query"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script definition to compute a custom document score"
        }
      },
      "title": "A query that wraps another query and uses custom scoring logic to compute the wrapped query's score"
    },
    "luceneserverFuzzyParams": {
      "type": "object",
      "properties": {
        "maxEdits": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum allowed Levenshtein Edit Distance (or number of edits). Possible values are 0, 1 and 2.\nEither set this or auto."
        },
        "prefixLength": {
          "type": "integer",
          "format": "int32",
          "title": "Length of common (non-fuzzy) prefix"
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32",
          "title": "The maximum number of terms to match"
        },
        "transpositions": {
          "type": "boolean",
          "description": "True if transpositions should be treated as a primitive edit operation. If this is false, comparisons\nwill implement the classic Levenshtein algorithm. Default is true."
        },
        "auto": {
          "$ref": "#/definitions/FuzzyParamsAutoFuzziness",
          "description": "Auto fuzziness which determines the max edits based on the term length. AUTO is the preferred setting.\nEither set this or maxEdits."
        }
      },
      "title": "Parameters for fuzzy queries"
    },
    "luceneserverFuzzyQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "text": {
          "type": "string",
          "title": "Term to search for"
        },
        "maxEdits": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum allowed Levenshtein Edit Distance (or number of edits). Possible values are 0, 1 and 2.\nEither set this or auto. Default is 2."
        },
        "prefixLength": {
          "type": "integer",
          "format": "int32",
          "description": "Length of common (non-fuzzy) prefix. Default is 0."
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of terms to match. Default is 50."
        },
        "transpositions": {
          "type": "boolean",
          "description": "True if transpositions should be treated as a primitive edit operation. If this is false, comparisons will\nimplement the classic Levenshtein algorithm. Default is true."
        },
        "rewrite": {
          "$ref": "#/definitions/luceneserverRewriteMethod",
          "title": "Method used to rewrite the query"
        },
        "rewriteTopTermsSize": {
          "type": "integer",
          "format": "int32",
          "title": "Specifies the size to use for the TOP_TERMS* rewrite methods"
        },
        "auto": {
          "$ref": "#/definitions/FuzzyParamsAutoFuzziness",
          "description": "Auto fuzziness which determines the max edits based on the term length. AUTO is the preferred setting.\nEither set this or maxEdits."
        }
      },
      "title": "A query that matches documents containing terms similar to the specified term"
    },
    "luceneserverGeoBoundingBoxQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "topLeft": {
          "$ref": "#/definitions/typeLatLng",
          "title": "Top left corner of the geo box"
        },
        "bottomRight": {
          "$ref": "#/definitions/typeLatLng",
          "title": "Bottom right corner of the geo box"
        }
      },
      "title": "A query that matches documents with geopoint within the geo box"
    },
    "luceneserverGeoPointQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "point": {
          "$ref": "#/definitions/typeLatLng",
          "title": "Point to check if the polygon contains"
        }
      },
      "title": "A query that matches documents with polygon that contains the geo point"
    },
    "luceneserverGeoPolygonQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "polygons": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverPolygon"
          },
          "title": "Geo polygons to search for containing points"
        }
      },
      "title": "A query that matches documents with geo points within polygons"
    },
    "luceneserverGeoRadiusQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "center": {
          "$ref": "#/definitions/typeLatLng",
          "title": "Target center geo point to calculate distance"
        },
        "radius": {
          "type": "string",
          "title": "Distance radius like \"12 km\". supports m, km and mi, default to m"
        }
      },
      "title": "A query that matches documents with geo point within the radius of target geo point"
    },
    "luceneserverGetAllSnapshotGenResponse": {
      "type": "object",
      "properties": {
        "indexGens": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          },
          "title": "List of snapshot gens"
        }
      },
      "title": "Response from Server for getAllSnapshotGen"
    },
    "luceneserverGetNodesResponse": {
      "type": "object",
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverNodeInfo"
          }
        }
      },
      "title": "Response from Server for getNodes"
    },
    "luceneserverGlobalStateInfo": {
      "type": "object",
      "properties": {
        "gen": {
          "type": "string",
          "format": "int64",
          "title": "State version generation"
        },
        "indices": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverIndexGlobalState"
          },
          "title": "Global state for indices"
        }
      },
      "title": "Cluster global state"
    },
    "luceneserverGlobalStateRequest": {
      "type": "object",
      "title": "Input to globalState"
    },
    "luceneserverGlobalStateResponse": {
      "type": "object",
      "properties": {
        "globalState": {
          "$ref": "#/definitions/luceneserverGlobalStateInfo",
          "title": "Cluster global state"
        }
      },
      "title": "Response from Server for globalState"
    },
    "luceneserverHealthCheckResponse": {
      "type": "object",
      "properties": {
        "health": {
          "$ref": "#/definitions/luceneserverTransferStatusCode",
          "title": "Response of healthcheck"
        }
      },
      "title": "Response from Server for healthCheck"
    },
    "luceneserverHighlight": {
      "type": "object",
      "properties": {
        "settings": {
          "$ref": "#/definitions/HighlightSettings",
          "title": "Highlight settings"
        },
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Fields to highlight"
        },
        "fieldSettings": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/HighlightSettings"
          },
          "title": "Map of field name to highlight settings for field, overrides request level highlight settings"
        }
      },
      "title": "Specify how to highlight matched text in SearchRequest"
    },
    "luceneserverHighlightType": {
      "type": "string",
      "enum": [
        "DEFAULT",
        "FAST_VECTOR",
        "PLAIN",
        "CUSTOM"
      ],
      "default": "DEFAULT",
      "title": "- DEFAULT: When DEFAULT is set in global setting, use fast vector highlighter; when set for field setting,\nuse the type from the global setting.\n - PLAIN: not supported yet"
    },
    "luceneserverHitsResult": {
      "type": "object",
      "properties": {
        "totalHits": {
          "$ref": "#/definitions/luceneserverTotalHits",
          "title": "Total hit information"
        },
        "hits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchResponseHit"
          },
          "title": "Ordered hits with scoring/sorting info and retrieved fields"
        }
      },
      "title": "Result from top hits collector"
    },
    "luceneserverIndexGlobalState": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "Unique identifier for index (yyyyMMddHHmmssSSS formatted date-time string)"
        },
        "started": {
          "type": "boolean",
          "title": "If index should be started"
        }
      },
      "title": "Per index information stored in global state"
    },
    "luceneserverIndexLiveSettings": {
      "type": "object",
      "properties": {
        "maxRefreshSec": {
          "type": "number",
          "format": "double",
          "title": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen), default: 1.0"
        },
        "minRefreshSec": {
          "type": "number",
          "format": "double",
          "title": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen),\ndefault: 0.05"
        },
        "maxSearcherAgeSec": {
          "type": "number",
          "format": "double",
          "title": "Non-current searchers older than this are pruned, default: 60.0"
        },
        "indexRamBufferSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Size (in MB) of IndexWriter's RAM buffer, default: 16.0"
        },
        "addDocumentsMaxBufferLen": {
          "type": "integer",
          "format": "int32",
          "title": "Max number of documents to add at a time, default: 100"
        },
        "sliceMaxDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of documents allowed in a parallel search slice, default: 250,000"
        },
        "sliceMaxSegments": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of segments allowed in a parallel search slice, default: 5"
        },
        "virtualShards": {
          "type": "integer",
          "format": "int32",
          "title": "Number of virtual shards to use for this index, default: 1"
        },
        "maxMergedSegmentMB": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum sized segment to produce during normal merging, default: 5GB"
        },
        "segmentsPerTier": {
          "type": "integer",
          "format": "int32",
          "title": "Number of segments per tier used by TieredMergePolicy, default: 10"
        },
        "defaultSearchTimeoutSec": {
          "type": "number",
          "format": "double",
          "title": "Timeout value to used when not specified in the search request, or 0 for no timeout, default: 0"
        },
        "defaultSearchTimeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "title": "Timeout check every value to use when not specified in the search request, or 0 for none, default: 0"
        },
        "defaultTerminateAfter": {
          "type": "integer",
          "format": "int32",
          "title": "Terminate after value to use when not specified in the search request, or 0 for none, default: 0"
        },
        "maxMergePreCopyDurationSec": {
          "type": "string",
          "format": "uint64",
          "title": "Merge precopy would be stopped after this time, or 0 for no checks, default: 0"
        },
        "verboseMetrics": {
          "type": "boolean",
          "title": "Collect and publish additional index metrics, which may be more expensive in terms of volume, memory\nand/or compute, default: false"
        },
        "parallelFetchByField": {
          "type": "boolean",
          "title": "If fetch parallelism should be done by groups of fields instead of document, default: false"
        },
        "parallelFetchChunkSize": {
          "type": "integer",
          "format": "int32",
          "title": "The number of documents/fields per parallel fetch task, default: 50"
        },
        "defaultTerminateAfterMaxRecallCount": {
          "type": "integer",
          "format": "int32",
          "title": "Terminate after max recall count value to use when not specified in the search request, or 0 for none, default: 0"
        }
      },
      "title": "Index live settings"
    },
    "luceneserverIndexOptions": {
      "type": "string",
      "enum": [
        "DEFAULT",
        "DOCS",
        "DOCS_FREQS",
        "DOCS_FREQS_POSITIONS",
        "DOCS_FREQS_POSITIONS_OFFSETS"
      ],
      "default": "DEFAULT",
      "description": "- DEFAULT: Use field default index options: ATOM=DOCS, TEXT=DOCS_FREQS_POSITIONS\n - DOCS: Index only doc ids\n - DOCS_FREQS: Index doc ids and term frequencies\n - DOCS_FREQS_POSITIONS: Index doc ids, term frequencies and positions\n - DOCS_FREQS_POSITIONS_OFFSETS: Index doc ids, term frequencies, positions and offsets",
      "title": "How text tokens should be indexed"
    },
    "luceneserverIndexPrefixes": {
      "type": "object",
      "properties": {
        "minChars": {
          "type": "integer",
          "format": "int32"
        },
        "maxChars": {
          "type": "integer",
          "format": "int32"
        }
      },
      "title": "Options for including IndexPrefixes for field"
    },
    "luceneserverIndexSettings": {
      "type": "object",
      "properties": {
        "nrtCachingDirectoryMaxMergeSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Largest merged segment size to cache in RAMDirectory, default: 5.0MB"
        },
        "nrtCachingDirectoryMaxSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Largest overall size for all files cached in NRTCachingDirectory, default: 60.0MB"
        },
        "concurrentMergeSchedulerMaxThreadCount": {
          "type": "integer",
          "format": "int32",
          "title": "How many merge threads to allow at once"
        },
        "concurrentMergeSchedulerMaxMergeCount": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum backlog of pending merges before indexing threads are stalled"
        },
        "indexSort": {
          "$ref": "#/definitions/luceneserverSortFields",
          "title": "Index time sorting; can only be written once\", SearchHandler.SORT_TYPE"
        },
        "indexMergeSchedulerAutoThrottle": {
          "type": "boolean",
          "title": "Turn on/off the merge scheduler's auto throttling, default: off"
        },
        "directory": {
          "type": "string",
          "description": "Base Directory implementation to use either one of the core implementations\n(FSDirectory, MMapDirectory, NIOFSDirectory, or a fully qualified path to a Directory\nimplementation that has a public constructor taking a single File argument default: FSDirectory.\nThis implementation will be wrapped by NRTCachingDirectory, if enabled and not using MMappedDirectory."
        }
      },
      "title": "Index offline settings"
    },
    "luceneserverIndexStateInfo": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of the index"
        },
        "gen": {
          "type": "string",
          "format": "int64",
          "title": "State version generation"
        },
        "committed": {
          "type": "boolean",
          "title": "If this index has ever been committed"
        },
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Index settings"
        },
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Index live settings"
        },
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverField"
          },
          "title": "Registered fields"
        }
      },
      "title": "Index state"
    },
    "luceneserverIndexStateRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        }
      },
      "title": "Input to indexState"
    },
    "luceneserverIndexStateResponse": {
      "type": "object",
      "properties": {
        "indexState": {
          "$ref": "#/definitions/luceneserverIndexStateInfo",
          "title": "Index state"
        }
      },
      "title": "Response from Server for indexState"
    },
    "luceneserverIndexStatsResponse": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        },
        "statsResponse": {
          "$ref": "#/definitions/luceneserverStatsResponse",
          "title": "Index stats"
        }
      },
      "title": "Index stats response"
    },
    "luceneserverIndicesResponse": {
      "type": "object",
      "properties": {
        "indicesResponse": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverIndexStatsResponse"
          },
          "title": "List of index stats"
        }
      },
      "title": "Response from Server for indices"
    },
    "luceneserverInnerHit": {
      "type": "object",
      "properties": {
        "queryNestedPath": {
          "type": "string",
          "title": "Nested path to search against assuming same index as the parent Query"
        },
        "startHit": {
          "type": "integer",
          "format": "int32",
          "title": "Which hit to start from (for pagination); default: 0"
        },
        "topHits": {
          "type": "integer",
          "format": "int32",
          "description": "How many top hits to retrieve; default: 3. It limits the hits returned, starting from index 0.\nFor pagination: set it to startHit + window_size."
        },
        "innerQuery": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "InnerHit query to query against the nested documents specified by queryNestedPath"
        },
        "retrieveFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Fields to retrieve; Parent's fields except its id field are unavailable in the innerHit"
        },
        "querySort": {
          "$ref": "#/definitions/luceneserverQuerySortField",
          "title": "Sort hits by field (default is by relevance)"
        },
        "highlight": {
          "$ref": "#/definitions/luceneserverHighlight",
          "title": "Highlight the children documents"
        }
      },
      "title": "Inner Hit search request"
    },
    "luceneserverIntObject": {
      "type": "object",
      "properties": {
        "int": {
          "type": "integer",
          "format": "int32",
          "title": "Value of the int"
        }
      },
      "title": "Used to be able to check if a value was set"
    },
    "luceneserverKnnQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Vector field name"
        },
        "filter": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Query used to filter vector search, or unset for no filter"
        },
        "k": {
          "type": "integer",
          "format": "int32",
          "title": "Number of top nearest neighbor documents to collect, must be \u003c= num_candidates"
        },
        "numCandidates": {
          "type": "integer",
          "format": "int32",
          "description": "Number of nearest neighbors to consider per segment. A larger value produces a more accurate top k.\nMust be \u003c= 10000."
        },
        "queryVector": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "title": "Vector value to use for query vector, for fields with float element type"
        },
        "queryByteVector": {
          "type": "string",
          "format": "byte",
          "title": "Vector value to use for query vector, for fields with byte element type"
        },
        "boost": {
          "type": "number",
          "format": "float",
          "title": "Boost multiplier for similarity score"
        }
      },
      "title": "Specification for kNN vector search query"
    },
    "luceneserverLabelAndValue": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "value": {
          "type": "number",
          "format": "double"
        }
      },
      "title": "Facet result label and value"
    },
    "luceneserverLastHitInfo": {
      "type": "object",
      "properties": {
        "lastFieldValues": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Last hit sort field values"
        },
        "lastDocId": {
          "type": "integer",
          "format": "int32",
          "title": "Last hit Lucene doc id"
        },
        "lastScore": {
          "type": "number",
          "format": "float",
          "title": "Last hit score"
        }
      },
      "title": "Last Hit info for search after"
    },
    "luceneserverLiveSettingsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of index whose liveSettings are to be updated"
        },
        "maxRefreshSec": {
          "type": "number",
          "format": "double",
          "title": "Longest time to wait before reopening IndexSearcher (i.e., periodic background reopen)"
        },
        "minRefreshSec": {
          "type": "number",
          "format": "double",
          "title": "Shortest time to wait before reopening IndexSearcher (i.e., when a search is waiting for a specific indexGen)"
        },
        "maxSearcherAgeSec": {
          "type": "number",
          "format": "double",
          "title": "Non-current searchers older than this are pruned"
        },
        "indexRamBufferSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Size (in MB) of IndexWriter's RAM buffer"
        },
        "addDocumentsMaxBufferLen": {
          "type": "integer",
          "format": "int32",
          "title": "Max number of documents to add at a time"
        },
        "sliceMaxDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of documents allowed in a parallel search slice"
        },
        "sliceMaxSegments": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of segments allowed in a parallel search slice"
        },
        "virtualShards": {
          "type": "integer",
          "format": "int32",
          "title": "Number of virtual shards to use for this index"
        },
        "maxMergedSegmentMB": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum sized segment to produce during normal merging"
        },
        "segmentsPerTier": {
          "type": "integer",
          "format": "int32",
          "title": "Number of segments per tier used by TieredMergePolicy"
        },
        "defaultSearchTimeoutSec": {
          "type": "number",
          "format": "double",
          "title": "Timeout value to used when not specified in the search request"
        },
        "defaultSearchTimeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "title": "Timeout check every value to use when not specified in the search request"
        },
        "defaultTerminateAfter": {
          "type": "integer",
          "format": "int32",
          "title": "Terminate after value to use when not specified in the search request"
        },
        "defaultTerminateAfterMaxRecallCount": {
          "type": "integer",
          "format": "int32",
          "description": "Terminate after max recall count value to use when not specified in the search request."
        }
      },
      "title": "Input to liveSettings"
    },
    "luceneserverLiveSettingsResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string",
          "title": "Json string of updated IndexLiveSettings"
        }
      },
      "title": "Response from Server to liveSettings"
    },
    "luceneserverLiveSettingsV2Request": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of index whose liveSettings are to be updated"
        },
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Live settings to merge into existing live settings, or unset to get current live settings"
        },
        "local": {
          "type": "boolean",
          "description": "When set to true, live settings changes are only applied to the local node. These changes are ephemeral,\nso will not persist through a restart. Also, the live settings returned in the response will contain the\nlocal overrides only when this flag is true."
        }
      },
      "title": "Input to liveSettingsV2"
    },
    "luceneserverLiveSettingsV2Response": {
      "type": "object",
      "properties": {
        "liveSettings": {
          "$ref": "#/definitions/luceneserverIndexLiveSettings",
          "title": "Current live settings, including default values"
        }
      },
      "title": "Response from Server to liveSettingsV2"
    },
    "luceneserverLoggingHits": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of the hits logger to be called, as registered by a HitsLoggerPlugin"
        },
        "params": {
          "type": "object",
          "title": "Optional logging parameters"
        },
        "hitsToLog": {
          "type": "integer",
          "format": "int32",
          "description": "number of hits to log. The number of final hits to be logged can be less than this number\nif a query has less hits."
        }
      },
      "title": "Defines logger for search hits"
    },
    "luceneserverMatchAllQuery": {
      "type": "object",
      "description": "A query that matches all documents."
    },
    "luceneserverMatchOperator": {
      "type": "string",
      "enum": [
        "SHOULD",
        "MUST"
      ],
      "default": "SHOULD",
      "description": "- SHOULD: Or operation\n - MUST: And operation",
      "title": "Type of match operator used in MatchQuery"
    },
    "luceneserverMatchPhrasePrefixQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "query": {
          "type": "string",
          "title": "The text to query with"
        },
        "slop": {
          "type": "integer",
          "format": "int32",
          "title": "Edit distance between respective positions of tokens generated by analyzing this query and the positions\nof terms in a document"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "description": "Analyzer used to analyze the query. If not provided, the default search analyzer for the field would\nbe used instead."
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of terms to which the last provided term of the query value will expand. Defaults to 50."
        }
      },
      "title": "A query that matches documents containing terms in the same order as those in the analyzed query string.\nThe final analyzed token is treated as a prefix"
    },
    "luceneserverMatchPhraseQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "query": {
          "type": "string",
          "title": "The text to query with"
        },
        "slop": {
          "type": "integer",
          "format": "int32",
          "title": "Edit distance between respective positions of tokens generated by analyzing this query and the positions of\nterms in a document"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "description": "Analyzer used to analyze the query. If not provided, the default search analyzer for the field would be\nused instead."
        },
        "zeroTermsQuery": {
          "$ref": "#/definitions/MatchPhraseQueryZeroTerms",
          "description": "Indicates whether none or all documents are returned if the analyzer removes all tokens. Valid values\nare NONE_ZERO_TERMS and ALL_ZERO_TERMS."
        }
      },
      "description": "A query that analyzes the text before finding matching documents. The tokens resulting from the analysis are\ncombined into a PhraseQuery."
    },
    "luceneserverMatchQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "query": {
          "type": "string",
          "title": "The text to query with"
        },
        "operator": {
          "$ref": "#/definitions/luceneserverMatchOperator",
          "description": "Boolean logic used to interpret text in the query. The possible values are SHOULD (default) and MUST."
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32",
          "title": "Minimum number of optional clauses that must match"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "description": "Analyzer used to analyze the query. If not provided, the default search analyzer for the field would be\nused instead."
        },
        "fuzzyParams": {
          "$ref": "#/definitions/luceneserverFuzzyParams",
          "title": "Parameters to set the fuzziness of the query"
        }
      },
      "description": "A query that analyzes the text before finding matching documents. The tokens resulting from the analysis are\ncombined using term queries in boolean clauses."
    },
    "luceneserverMaxCollector": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script to produce a double value"
        }
      },
      "description": "Definition of collector to find a max double value over documents. Currently only allows for script based\nvalue production."
    },
    "luceneserverMinCollector": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script to produce a double value"
        }
      },
      "description": "Definition of collector to find a min double value over documents. Currently only allows for script based\nvalue production."
    },
    "luceneserverMode": {
      "type": "string",
      "enum": [
        "STANDALONE",
        "PRIMARY",
        "REPLICA"
      ],
      "default": "STANDALONE",
      "description": "- STANDALONE: Standalone index with no replication\n - PRIMARY: Primary index in an nrt cluster setup\n - REPLICA: Replica index in an nrt cluster setup",
      "title": "Index start mode"
    },
    "luceneserverMultiFunctionScoreQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Main query to produce recalled docs and scores, which will be modified by the final function score"
        },
        "functions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MultiFunctionScoreQueryFilterFunction"
          },
          "title": "Functions to produce final function score"
        },
        "scoreMode": {
          "$ref": "#/definitions/MultiFunctionScoreQueryFunctionScoreMode",
          "title": "Method to combine functions scores"
        },
        "boostMode": {
          "$ref": "#/definitions/MultiFunctionScoreQueryBoostMode",
          "title": "Method to modify query document scores with final function score"
        },
        "minScore": {
          "type": "number",
          "format": "float",
          "description": "Optional minimal score to match a document. By default, it's 0."
        },
        "minExcluded": {
          "type": "boolean",
          "description": "Determine minimal score is excluded or not. By default, it's false."
        }
      },
      "title": "A query to modify the score of documents with a given set of functions"
    },
    "luceneserverMultiMatchQuery": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Fields in the document to query"
        },
        "query": {
          "type": "string",
          "title": "The text to query with"
        },
        "fieldBoosts": {
          "type": "object",
          "additionalProperties": {
            "type": "number",
            "format": "float"
          },
          "title": "Boosts for each field, if any"
        },
        "operator": {
          "$ref": "#/definitions/luceneserverMatchOperator",
          "description": "Boolean logic used to interpret text in the query. The possible values are SHOULD (default) and MUST."
        },
        "minimumNumberShouldMatch": {
          "type": "integer",
          "format": "int32",
          "title": "Minimum number of optional clauses that must match"
        },
        "analyzer": {
          "$ref": "#/definitions/luceneserverAnalyzer",
          "description": "Analyzer used to analyze the query. If not provided, the default search analyzer for the field would\nbe used instead."
        },
        "fuzzyParams": {
          "$ref": "#/definitions/luceneserverFuzzyParams",
          "title": "Parameters to set the fuzziness of the query"
        },
        "tieBreakerMultiplier": {
          "type": "number",
          "format": "float",
          "title": "The score of each non-maximum match query disjunct for a document will be multiplied by this weight\nand added into the final score"
        },
        "type": {
          "$ref": "#/definitions/MultiMatchQueryMatchType",
          "title": "Type defining match behavior of query"
        },
        "slop": {
          "type": "integer",
          "format": "int32",
          "title": "Edit distance between respective positions of tokens generated by analyzing this query and the positions\nof terms in a document, applies to PHRASE_PREFIX type matching"
        },
        "maxExpansions": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of terms to which the prefix token will expand when using PHRASE_PREFIX matching. Defaults to 50."
        }
      },
      "description": "A query that creates a match query for each field provided and wraps all the match queries in a\ndisjunction max query."
    },
    "luceneserverNameAndParams": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of the analysis component"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Parameters for the analysis component"
        }
      },
      "title": "Name of analysis component and its parameters"
    },
    "luceneserverNestedQuery": {
      "type": "object",
      "properties": {
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Query for the child documents"
        },
        "path": {
          "type": "string",
          "title": "Path to the child document"
        },
        "scoreMode": {
          "$ref": "#/definitions/NestedQueryScoreMode",
          "title": "How child documents score affects final score"
        }
      },
      "title": "Query that matches nested documents"
    },
    "luceneserverNodeInfo": {
      "type": "object",
      "properties": {
        "hostname": {
          "type": "string",
          "title": "Name or ip address of the remote host that this node is connected to for binary replication"
        },
        "port": {
          "type": "integer",
          "format": "int32",
          "title": "Port number of the remote host that this node is connected to for binary replication"
        },
        "nodeName": {
          "type": "string",
          "title": "Name of the remote node"
        }
      },
      "title": "Node information"
    },
    "luceneserverNodeInfoResponse": {
      "type": "object",
      "properties": {
        "nodeName": {
          "type": "string",
          "title": "Node name"
        },
        "serviceName": {
          "type": "string",
          "title": "Service name"
        },
        "hostName": {
          "type": "string",
          "title": "Host name"
        },
        "version": {
          "type": "string",
          "title": "Nrtsearch version"
        },
        "ephemeralId": {
          "type": "string",
          "title": "Node ephemeral id"
        }
      },
      "title": "Response from Server for nodeInfo"
    },
    "luceneserverNumericRangeType": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string",
          "title": "Label for this range"
        },
        "min": {
          "type": "string",
          "format": "int64",
          "title": "Min value for the range"
        },
        "minInclusive": {
          "type": "boolean",
          "title": "True if the min value is inclusive"
        },
        "max": {
          "type": "string",
          "format": "int64",
          "title": "Max value for the range"
        },
        "maxInclusive": {
          "type": "boolean",
          "title": "True if the max value is inclusive"
        }
      },
      "title": "Define numeric range for facet"
    },
    "luceneserverPhraseQuery": {
      "type": "object",
      "properties": {
        "slop": {
          "type": "integer",
          "format": "int32",
          "title": "Edit distance between respective positions of terms as defined in this PhraseQuery and the positions\nof terms in a document"
        },
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "terms": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Terms to match"
        }
      },
      "title": "A Query that matches documents containing a particular sequence of terms"
    },
    "luceneserverPluginCollector": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of plugin registered collector"
        },
        "params": {
          "type": "object",
          "title": "Arguments passed to the plugin collector"
        }
      },
      "title": "Defines an entry point for using a collector from a plugin"
    },
    "luceneserverPluginRescorer": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Rescorer name registered by plugin"
        },
        "params": {
          "type": "object",
          "title": "Arguments passed to the plugin rescorer"
        }
      },
      "title": "Defines an entry point for using a rescorer from plugin"
    },
    "luceneserverPoint": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double",
          "title": "Latitude of the point"
        },
        "longitude": {
          "type": "number",
          "format": "double",
          "title": "Longitude of the point"
        }
      },
      "title": "Point representation"
    },
    "luceneserverPolygon": {
      "type": "object",
      "properties": {
        "points": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/typeLatLng"
          },
          "description": "Points defining the polygon, conforming to the https://geojson.org/ standard. The polygon must not be\nself-crossing, otherwise may result in unexpected behavior. Polygons cannot cross the 180th meridian.\nInstead, use two polygons: one on each side."
        },
        "holes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverPolygon"
          },
          "description": "Specify holes in the polygon. Hole polygons cannot themselves contain holes."
        }
      },
      "title": "Polygon defined by a list of geo points"
    },
    "luceneserverPrefixQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Document field name"
        },
        "prefix": {
          "type": "string",
          "title": "Prefix to search for"
        },
        "rewrite": {
          "$ref": "#/definitions/luceneserverRewriteMethod",
          "title": "Method used to rewrite the query"
        },
        "rewriteTopTermsSize": {
          "type": "integer",
          "format": "int32",
          "title": "Specifies the size to use for the TOP_TERMS* rewrite methods"
        }
      },
      "title": "A query that matches documents that contain a specific prefix in a provided field"
    },
    "luceneserverProfileResult": {
      "type": "object",
      "properties": {
        "searchStats": {
          "$ref": "#/definitions/ProfileResultSearchStats",
          "title": "Stats for search phase"
        },
        "parsedQuery": {
          "type": "string",
          "title": "Parsed query string"
        },
        "rewrittenQuery": {
          "type": "string",
          "title": "Rewritten query string"
        },
        "drillDownQuery": {
          "type": "string",
          "title": "Drill down query string"
        }
      },
      "title": "Defines detailed profiling stats for queries that set profile=true"
    },
    "luceneserverQuery": {
      "type": "object",
      "properties": {
        "queryType": {
          "$ref": "#/definitions/luceneserverQueryType",
          "title": "No longer needed, type inferred from set QueryNode"
        },
        "boost": {
          "type": "number",
          "format": "float",
          "description": "Boost values that are less than one will give less importance to this query compared to other ones while\nvalues that are greater than one will give more importance to the scores returned by this query. Boost\nvalue of zero will do nothing (default). Boost less than 0 is invalid."
        },
        "booleanQuery": {
          "$ref": "#/definitions/luceneserverBooleanQuery"
        },
        "phraseQuery": {
          "$ref": "#/definitions/luceneserverPhraseQuery"
        },
        "functionScoreQuery": {
          "$ref": "#/definitions/luceneserverFunctionScoreQuery"
        },
        "termQuery": {
          "$ref": "#/definitions/luceneserverTermQuery"
        },
        "termInSetQuery": {
          "$ref": "#/definitions/luceneserverTermInSetQuery"
        },
        "disjunctionMaxQuery": {
          "$ref": "#/definitions/luceneserverDisjunctionMaxQuery"
        },
        "matchQuery": {
          "$ref": "#/definitions/luceneserverMatchQuery"
        },
        "matchPhraseQuery": {
          "$ref": "#/definitions/luceneserverMatchPhraseQuery"
        },
        "multiMatchQuery": {
          "$ref": "#/definitions/luceneserverMultiMatchQuery"
        },
        "rangeQuery": {
          "$ref": "#/definitions/luceneserverRangeQuery"
        },
        "geoBoundingBoxQuery": {
          "$ref": "#/definitions/luceneserverGeoBoundingBoxQuery"
        },
        "geoPointQuery": {
          "$ref": "#/definitions/luceneserverGeoPointQuery"
        },
        "nestedQuery": {
          "$ref": "#/definitions/luceneserverNestedQuery"
        },
        "existsQuery": {
          "$ref": "#/definitions/luceneserverExistsQuery"
        },
        "geoRadiusQuery": {
          "$ref": "#/definitions/luceneserverGeoRadiusQuery"
        },
        "functionFilterQuery": {
          "$ref": "#/definitions/luceneserverFunctionFilterQuery"
        },
        "completionQuery": {
          "$ref": "#/definitions/luceneserverCompletionQuery"
        },
        "multiFunctionScoreQuery": {
          "$ref": "#/definitions/luceneserverMultiFunctionScoreQuery"
        },
        "matchPhrasePrefixQuery": {
          "$ref": "#/definitions/luceneserverMatchPhrasePrefixQuery"
        },
        "prefixQuery": {
          "$ref": "#/definitions/luceneserverPrefixQuery"
        },
        "constantScoreQuery": {
          "$ref": "#/definitions/luceneserverConstantScoreQuery"
        },
        "geoPolygonQuery": {
          "$ref": "#/definitions/luceneserverGeoPolygonQuery"
        },
        "spanQuery": {
          "$ref": "#/definitions/luceneserverSpanQuery"
        },
        "matchAllQuery": {
          "$ref": "#/definitions/luceneserverMatchAllQuery"
        },
        "exactVectorQuery": {
          "$ref": "#/definitions/luceneserverExactVectorQuery"
        }
      },
      "title": "Defines a full query consisting of a QueryNode which may be one of several types"
    },
    "luceneserverQueryRescorer": {
      "type": "object",
      "properties": {
        "rescoreQuery": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Query to rescore documents"
        },
        "queryWeight": {
          "type": "number",
          "format": "double",
          "title": "Weight to multiply with original query score"
        },
        "rescoreQueryWeight": {
          "type": "number",
          "format": "double",
          "title": "Weight to multiply with rescore query score"
        }
      },
      "title": "Defines a rescorer which uses query to rescore documents in the second pass"
    },
    "luceneserverQuerySortField": {
      "type": "object",
      "properties": {
        "doDocScores": {
          "type": "boolean",
          "title": "Compute the doc score for each collected (costs added CPU); default:false"
        },
        "doMaxScore": {
          "type": "boolean",
          "title": "Compute the max score across all hits (costs added CPU); default: false"
        },
        "fields": {
          "$ref": "#/definitions/luceneserverSortFields",
          "title": "List of Fields to sort on"
        }
      },
      "title": "Definition doing ranking by sorting on fields"
    },
    "luceneserverQueryType": {
      "type": "string",
      "enum": [
        "NONE",
        "BOOLEAN_QUERY",
        "PHRASE_QUERY",
        "FUNCTION_SCORE_QUERY",
        "TERM_QUERY",
        "TERM_IN_SET_QUERY",
        "DISJUNCTION_MAX",
        "MATCH",
        "MATCH_PHRASE",
        "MULTI_MATCH",
        "RANGE",
        "GEO_BOUNDING_BOX",
        "GEO_POINT",
        "NESTED",
        "EXISTS",
        "GEO_RADIUS",
        "COMPLETION",
        "MULTI_FUNCTION_SCORE_QUERY",
        "MATCH_PHRASE_PREFIX",
        "PREFIX",
        "CONSTANT_SCORE_QUERY",
        "GEO_POLYGON",
        "SPAN_QUERY"
      ],
      "default": "NONE",
      "title": "Deprecated: Defines different types of QueryNodes"
    },
    "luceneserverRangeQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "lower": {
          "type": "string",
          "title": "Lower bound, inclusive by default"
        },
        "upper": {
          "type": "string",
          "title": "Upper bound, inclusive by default"
        },
        "lowerExclusive": {
          "type": "boolean",
          "title": "Set true to make lower bound exclusive"
        },
        "upperExclusive": {
          "type": "boolean",
          "title": "Set true to make upper bound exclusive"
        }
      },
      "description": "A query that matches documents with values within the specified range. The lower and upper values though provided\nas strings will be converted to the type of the field. This works with INT, LONG, FLOAT, DOUBLE and DATE_TIME\nfield types."
    },
    "luceneserverRawFileChunk": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string",
          "format": "byte",
          "title": "Raw contents of file"
        },
        "seqNum": {
          "type": "integer",
          "format": "int32",
          "title": "Sequence number for this chunk, only used for acked file copy"
        },
        "ack": {
          "type": "boolean",
          "title": "If this chunk should be acked, only used for acked file copy"
        }
      },
      "title": "Chunk of file data"
    },
    "luceneserverRefreshRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to be refreshed"
        }
      },
      "title": "Input to refresh"
    },
    "luceneserverRefreshResponse": {
      "type": "object",
      "properties": {
        "refreshTimeMS": {
          "type": "number",
          "format": "double",
          "title": "Time taken in milliseconds to refresh the index"
        }
      },
      "title": "Response from Server for refresh"
    },
    "luceneserverRegexpFlag": {
      "type": "string",
      "enum": [
        "REGEXP_ALL",
        "REGEXP_ANYSTRING",
        "REGEXP_AUTOMATON",
        "REGEXP_COMPLEMENT",
        "REGEXP_EMPTY",
        "REGEXP_INTERSECTION",
        "REGEXP_INTERVAL",
        "REGEXP_NONE"
      ],
      "default": "REGEXP_ALL",
      "description": "- REGEXP_ALL: Syntax flag, enables all optional regexp syntax\n - REGEXP_ANYSTRING: Syntax flag, enables anystring (@)\n - REGEXP_AUTOMATON: Syntax flag, enables named automata (\u003cidentifier\u003e)\n - REGEXP_COMPLEMENT: Syntax flag, enables complement (~)\n - REGEXP_EMPTY: Syntax flag, enables empty language (#)\n - REGEXP_INTERSECTION: Syntax flag, enables intersection (\u0026)\n - REGEXP_INTERVAL: Syntax flag, enables numerical intervals (\u003cn-m\u003e)\n - REGEXP_NONE: Syntax flag, enables no optional regexp syntax",
      "title": "Enum for RegexpQuery flags"
    },
    "luceneserverRegexpQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "text": {
          "type": "string",
          "title": "Regular expression to search for"
        },
        "flag": {
          "$ref": "#/definitions/luceneserverRegexpFlag",
          "title": "Optional flags for the regular expression"
        },
        "maxDeterminizedStates": {
          "type": "integer",
          "format": "int32",
          "description": "Maximum number of states that compiling the automaton for the regexp can result in. Set higher to allow more\ncomplex queries and lower to prevent memory exhaustion. Default is 10000."
        },
        "rewrite": {
          "$ref": "#/definitions/luceneserverRewriteMethod",
          "title": "Method used to rewrite the query"
        },
        "rewriteTopTermsSize": {
          "type": "integer",
          "format": "int32",
          "title": "Specifies the size to use for the TOP_TERMS* rewrite methods"
        }
      },
      "title": "Message for RegexpQuery"
    },
    "luceneserverReleaseSnapshotRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of the index to release snapshot"
        },
        "snapshotId": {
          "$ref": "#/definitions/luceneserverSnapshotId",
          "title": "Id of snapshot to release, previously returned by @createSnapshot"
        }
      },
      "title": "Input to releaseSnapshot"
    },
    "luceneserverReleaseSnapshotResponse": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "title": "True if successful"
        }
      },
      "title": "Response from Server for releaseSnapshot"
    },
    "luceneserverReloadStateRequest": {
      "type": "object",
      "title": "Input to reloadState"
    },
    "luceneserverReloadStateResponse": {
      "type": "object",
      "title": "Response from Server for reloadState"
    },
    "luceneserverRescorer": {
      "type": "object",
      "properties": {
        "windowSize": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of hits from previous phase to rescore"
        },
        "queryRescorer": {
          "$ref": "#/definitions/luceneserverQueryRescorer",
          "title": "Rescore with Lucene query"
        },
        "pluginRescorer": {
          "$ref": "#/definitions/luceneserverPluginRescorer",
          "title": "Rescore with plugin registered rescorer"
        },
        "name": {
          "type": "string",
          "title": "Must be unique for each Rescorer"
        }
      },
      "title": "Defines a rescorer which is executed after the first search pass"
    },
    "luceneserverRestoreIndex": {
      "type": "object",
      "properties": {
        "serviceName": {
          "type": "string",
          "title": "Remote storage namespace qualifier for service"
        },
        "resourceName": {
          "type": "string",
          "title": "Remote storage namespace qualifier for resource e.g. indexName"
        },
        "deleteExistingData": {
          "type": "boolean",
          "title": "Delete any existing local data for the index"
        }
      },
      "title": "Index restore information"
    },
    "luceneserverRewriteMethod": {
      "type": "string",
      "enum": [
        "CONSTANT_SCORE",
        "CONSTANT_SCORE_BOOLEAN",
        "SCORING_BOOLEAN",
        "TOP_TERMS_BLENDED_FREQS",
        "TOP_TERMS_BOOST",
        "TOP_TERMS"
      ],
      "default": "CONSTANT_SCORE",
      "description": "- CONSTANT_SCORE: Uses the CONSTANT_SCORE_BOOLEAN method for fewer matching terms. Otherwise, this method finds all matching\nterms in sequence and returns matching documents using a bit set.\n - CONSTANT_SCORE_BOOLEAN: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each\nmatching term.\n - SCORING_BOOLEAN: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each\nmatching term. Calculates the relevance score for each matching document.\n - TOP_TERMS_BLENDED_FREQS: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each\nmatching term. Calculates a relevance score for each matching document as if all terms had the same frequency,\nthe maximum frequency of all matching terms. The final BooleanQuery query only includes Term queries for\nthe top N (specified separately) scoring terms.\n - TOP_TERMS_BOOST: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each\nmatching term. Assigns each matching document a relevance score equal to the boost parameter. The final\nBooleanQuery query only includes Term queries for the top N (specified separately) terms.\n - TOP_TERMS: This method changes the original query to a BooleanQuery, containing a SHOULD clause and TermQuery for each\nmatching term. Calculates a relevance score for each matching document. The final BooleanQuery query only\nincludes Term queries for the top N (specified separately) scoring terms.",
      "title": "Method used to rewrite a MultiTermQuery"
    },
    "luceneserverRuntimeField": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script defining this field's values"
        },
        "name": {
          "type": "string",
          "description": "Runtime field's name. Must be different from registered fields and any other runtime fields."
        }
      },
      "title": "Runtime field used during search"
    },
    "luceneserverScript": {
      "type": "object",
      "properties": {
        "lang": {
          "type": "string",
          "title": "Script language"
        },
        "source": {
          "type": "string",
          "title": "Script source"
        },
        "params": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ScriptParamValue"
          },
          "title": "Parameters passed into script execution"
        }
      },
      "title": "Definition of user-defined script"
    },
    "luceneserverSearchRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index to search against"
        },
        "startHit": {
          "type": "integer",
          "format": "int32",
          "title": "Which hit to start from (for pagination); default: 0"
        },
        "topHits": {
          "type": "integer",
          "format": "int32",
          "description": "How many top hits to retrieve; default: 10. It limits the hits returned, starting from index 0.\nFor pagination: set it to startHit + window_size."
        },
        "timeoutSec": {
          "type": "number",
          "format": "double",
          "description": "Maximum number of seconds spent on each collection phase; note that for\nmulti-pass searches (e.g. query-time grouping), this timeout applies to each phase."
        },
        "retrieveFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Which fields to retrieve"
        },
        "queryText": {
          "type": "string",
          "description": "Query text to parse using the specified QueryParser. If query is provided, this is ignored."
        },
        "virtualFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverVirtualField"
          },
          "title": "Defines virtual fields (named dynamic expressions) for this query"
        },
        "query": {
          "$ref": "#/definitions/luceneserverQuery",
          "title": "Full query to execute"
        },
        "querySort": {
          "$ref": "#/definitions/luceneserverQuerySortField",
          "title": "Sort hits by field (default is by relevance)"
        },
        "indexGen": {
          "type": "string",
          "format": "int64",
          "description": "Search a generation previously returned by an indexing operation such as #addDocument.\nUse this to search a non-committed (near-real-time) view of the index."
        },
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Search a specific searcher version. This is typically used by follow-on searches\n(e.g., user clicks next page, drills down, or changes sort, etc.) to get the same searcher used by\nthe original search."
        },
        "snapshot": {
          "type": "string",
          "title": "Search a snapshot previously created with #createSnapshot"
        },
        "totalHitsThreshold": {
          "type": "integer",
          "format": "int32",
          "description": "By default we count hits accurately up to 1000. This makes sure that we don't spend most time on\ncomputing hit counts."
        },
        "facets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacet"
          },
          "title": "Which facets to retrieve"
        },
        "fetchTasks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFetchTask"
          },
          "title": "Any custom tasks that should be performed on top documents after ranking"
        },
        "disallowPartialResults": {
          "type": "boolean",
          "description": "Should partial result be a failure condition. Applies when a search request times out. If false, the top\ndocuments ranking at the point of timeout are used and the request continues. Also, hitTimeout is set to\ntrue in the response."
        },
        "queryNestedPath": {
          "type": "string",
          "title": "Nested path we want to query by if we want to query child documents"
        },
        "rescorers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverRescorer"
          },
          "title": "Rescorers which are executed in-order after the first pass"
        },
        "profile": {
          "type": "boolean",
          "title": "If detailed request execution profiling should be included in the response"
        },
        "timeoutCheckEvery": {
          "type": "integer",
          "format": "int32",
          "description": "Check the search timeout condition after each collection of n documents in a segment.\nIf 0, timeout is only checked on the segment boundary."
        },
        "collectors": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollector"
          },
          "description": "Additional document collectors. Provides support for operations such as aggregation."
        },
        "terminateAfter": {
          "type": "integer",
          "format": "int32",
          "title": "Stop document collection in search phase after this many documents, 0 for unlimited"
        },
        "responseCompression": {
          "type": "string",
          "title": "Set gRPC compression codec to use for response message. If value is unset or invalid, falls back to\nuncompressed. Valid codecs: identity, gzip, lz4"
        },
        "highlight": {
          "$ref": "#/definitions/luceneserverHighlight",
          "title": "Specify how to highlight matched text"
        },
        "explain": {
          "type": "boolean",
          "title": "If Lucene explanation should be included in the response"
        },
        "innerHits": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverInnerHit"
          },
          "title": "Search nested object fields for each hit"
        },
        "runtimeFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverRuntimeField"
          },
          "title": "Defines runtime fields for this query"
        },
        "terminateAfterMaxRecallCount": {
          "type": "integer",
          "format": "int32",
          "title": "Stop document collection in search phase after this many recalled documents, after terminateAfter docs\nwill be counted but not scored upto terminateAfterMaxRecallCount"
        },
        "loggingHits": {
          "$ref": "#/definitions/luceneserverLoggingHits",
          "title": "Any custom logging that should log hits after ranking"
        },
        "searchAfter": {
          "$ref": "#/definitions/luceneserverLastHitInfo",
          "title": "Keeps tracks of last hit for search after"
        },
        "knn": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverKnnQuery"
          },
          "title": "Request kNN vector search queries, results will be combined with the standard query (if provided) using\nthe boolean query SHOULD logic"
        }
      },
      "title": "Search query request"
    },
    "luceneserverSearchResponse": {
      "type": "object",
      "properties": {
        "diagnostics": {
          "$ref": "#/definitions/SearchResponseDiagnostics",
          "title": "Query diagnostics"
        },
        "hitTimeout": {
          "type": "boolean",
          "title": "Set to true if search times out and a degraded response is returned"
        },
        "totalHits": {
          "$ref": "#/definitions/luceneserverTotalHits",
          "title": "Total hits for the query"
        },
        "hits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchResponseHit"
          },
          "title": "Ranked top hits"
        },
        "searchState": {
          "$ref": "#/definitions/SearchResponseSearchState",
          "title": "State for use in subsequent searches (search after)"
        },
        "facetResult": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverFacetResult"
          },
          "title": "Counts or aggregates for a single dimension"
        },
        "profileResult": {
          "$ref": "#/definitions/luceneserverProfileResult",
          "title": "Detailed stats returned when profile=true in request"
        },
        "collectorResults": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/luceneserverCollectorResult"
          },
          "title": "Results from any additional document collectors"
        },
        "terminatedEarly": {
          "type": "boolean",
          "title": "If this query hit the terminateAfter threshold specified in the request"
        }
      },
      "title": "Response to a search request"
    },
    "luceneserverSearcher": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Version recorded in the commit that the reader opened. This version is advanced every time a change\nis made with IndexWriter."
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Total number of docs in this index"
        },
        "segments": {
          "type": "string",
          "title": "String representation of segments"
        },
        "staleAgeSeconds": {
          "type": "number",
          "format": "double",
          "title": "How much time has passed since this searcher was the current (live) searcher"
        },
        "numSegments": {
          "type": "integer",
          "format": "int32",
          "title": "Number of segments, filled only if Searcher has StandardDirectoryReader"
        }
      },
      "title": "Index searcher stats"
    },
    "luceneserverSearcherVersion": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Version recorded in the commit that the reader opened. This version is advanced every time a change\nis made with IndexWriter."
        },
        "didRefresh": {
          "type": "boolean",
          "title": "True if refresh happened"
        }
      },
      "title": "Index searcher version"
    },
    "luceneserverSelector": {
      "type": "string",
      "enum": [
        "MIN",
        "MAX",
        "MIDDLE_MIN",
        "MIDDLE_MAX"
      ],
      "default": "MIN",
      "description": "- MIN: Minimum value\n - MAX: Maximum value\n - MIDDLE_MIN: Middle value of the set; if there are an even number of values, the lower of the middle two is chosen\n - MIDDLE_MAX: Middle value of the set; if there are an even number of values, the upper of the middle two is chosen",
      "title": "For multi valued fields, how to select which value is used for sorting"
    },
    "luceneserverSettingsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Name of index whose settings are to be updated"
        },
        "mergeMaxMBPerSec": {
          "type": "number",
          "format": "double",
          "title": "No longer used"
        },
        "nrtCachingDirectoryMaxMergeSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Largest merged segment size to cache in RAMDirectory, default: 5.0MB"
        },
        "nrtCachingDirectoryMaxSizeMB": {
          "type": "number",
          "format": "double",
          "title": "Largest overall size for all files cached in NRTCachingDirectory; set to -1 to disable NRTCachingDirectory,\ndefault: 60.0MB"
        },
        "concurrentMergeSchedulerMaxThreadCount": {
          "type": "integer",
          "format": "int32",
          "title": "How many merge threads to allow at once"
        },
        "concurrentMergeSchedulerMaxMergeCount": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum backlog of pending merges before indexing threads are stalled"
        },
        "indexSort": {
          "$ref": "#/definitions/luceneserverSortFields",
          "title": "Index time sorting; can only be written once, default: no sorting"
        },
        "indexVerbose": {
          "type": "boolean",
          "title": "Deprecated, moved to lucene config. Turn on IndexWriter's infoStream (to stdout)"
        },
        "indexMergeSchedulerAutoThrottle": {
          "type": "boolean",
          "title": "Turn on/off the merge scheduler's auto throttling"
        },
        "normsFormat": {
          "type": "string",
          "title": "No longer used"
        },
        "directory": {
          "type": "string",
          "description": "Base Directory implementation to use either one of the core implementations\n(FSDirectory, MMapDirectory, NIOFSDirectory, or a fully qualified path to a Directory\nimplementation that has a public constructor taking a single File argument default: FSDirectory.\nThis implementation will be wrapped by NRTCachingDirectory, if enabled and not using MMappedDirectory."
        }
      },
      "title": "Input to settings"
    },
    "luceneserverSettingsResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string",
          "title": "Json string of updated IndexSettings"
        }
      },
      "title": "Settings Response returned from Server"
    },
    "luceneserverSettingsV2Request": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        },
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Settings to merge into existing settings, or unset to get current settings"
        }
      },
      "title": "Input to settingsV2"
    },
    "luceneserverSettingsV2Response": {
      "type": "object",
      "properties": {
        "settings": {
          "$ref": "#/definitions/luceneserverIndexSettings",
          "title": "Current index settings, including default values"
        }
      },
      "title": "Response from Server for settingsV2"
    },
    "luceneserverSnapshotId": {
      "type": "object",
      "properties": {
        "indexGen": {
          "type": "string",
          "format": "int64",
          "title": "Index generation"
        },
        "taxonomyGen": {
          "type": "string",
          "format": "int64",
          "title": "Taxonomy index generation"
        },
        "stateGen": {
          "type": "string",
          "format": "int64",
          "title": "State generation"
        }
      },
      "title": "Snapshot id"
    },
    "luceneserverSortFields": {
      "type": "object",
      "properties": {
        "sortedFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSortType"
          },
          "title": "Fields to sort on"
        }
      },
      "title": "Fields to sort on either during index time or search time"
    },
    "luceneserverSortType": {
      "type": "object",
      "properties": {
        "fieldName": {
          "type": "string",
          "title": "Name of field to sort on"
        },
        "selector": {
          "$ref": "#/definitions/luceneserverSelector",
          "title": "For multi valued fields, how to select which value is used for sorting"
        },
        "origin": {
          "$ref": "#/definitions/luceneserverPoint",
          "title": "For distance sort, the point that we measure distance from"
        },
        "missingLast": {
          "type": "boolean",
          "description": "Whether missing values should sort last instead of first.\nNote that this runs \\\"before\\\" reverse, so if you sort missing first and reverse=true then missing values will\nbe at the end."
        },
        "reverse": {
          "type": "boolean",
          "title": "Sort in reverse of the field's natural order"
        },
        "unit": {
          "type": "string",
          "title": "The unit used for the distance sort. Supported options are m, km and mi, default is m"
        }
      },
      "description": "The field to sort on. Pass 'docid' for index order and 'score' for relevance sort."
    },
    "luceneserverSpanMultiTermQuery": {
      "type": "object",
      "properties": {
        "wildcardQuery": {
          "$ref": "#/definitions/luceneserverWildcardQuery"
        },
        "fuzzyQuery": {
          "$ref": "#/definitions/luceneserverFuzzyQuery"
        },
        "prefixQuery": {
          "$ref": "#/definitions/luceneserverPrefixQuery"
        },
        "regexpQuery": {
          "$ref": "#/definitions/luceneserverRegexpQuery"
        },
        "termRangeQuery": {
          "$ref": "#/definitions/luceneserverTermRangeQuery"
        }
      },
      "title": "Message for a SpanMultiTermQuery"
    },
    "luceneserverSpanNearQuery": {
      "type": "object",
      "properties": {
        "clauses": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSpanQuery"
          },
          "title": "Clauses for a span near query"
        },
        "slop": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of positions between matching terms"
        },
        "inOrder": {
          "type": "boolean",
          "title": "True if the matching terms must be in the same order as the query"
        }
      },
      "title": "A query that matches documents containing terms within a specified range"
    },
    "luceneserverSpanQuery": {
      "type": "object",
      "properties": {
        "spanTermQuery": {
          "$ref": "#/definitions/luceneserverTermQuery"
        },
        "spanNearQuery": {
          "$ref": "#/definitions/luceneserverSpanNearQuery"
        },
        "spanMultiTermQuery": {
          "$ref": "#/definitions/luceneserverSpanMultiTermQuery"
        }
      },
      "title": "Wrapper message for different types of SpanQuery"
    },
    "luceneserverStartIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        },
        "mode": {
          "$ref": "#/definitions/luceneserverMode",
          "title": "Mode to start this index: Standalone, NRT primary or replica"
        },
        "primaryGen": {
          "type": "string",
          "format": "int64",
          "description": "Generation of this primary (should increase each time a new primary starts for this index).\nPass -1 use generation based on epoch time."
        },
        "primaryAddress": {
          "type": "string",
          "title": "Replica config: the IP address or host name of the remote primary"
        },
        "port": {
          "type": "integer",
          "format": "int32",
          "title": "Replica config: the TCP port of the remote primary"
        },
        "restore": {
          "$ref": "#/definitions/luceneserverRestoreIndex",
          "title": "Restore index from backup"
        },
        "primaryDiscoveryFile": {
          "type": "string",
          "description": "Replica config: location of discovery file containing primary host/port. Used if primaryAddress is empty.\nIf port is specified in this request, it overrides the port value in the file."
        }
      },
      "title": "Input to startIndex"
    },
    "luceneserverStartIndexResponse": {
      "type": "object",
      "properties": {
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "title": "One greater than the largest possible document number"
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "title": "Number of documents in this index"
        },
        "segments": {
          "type": "string",
          "title": "String representation of the IndexReader implementation"
        },
        "startTimeMS": {
          "type": "number",
          "format": "double",
          "title": "Time taken to start the index"
        }
      },
      "title": "Response from Server for startIndex"
    },
    "luceneserverStartIndexV2Request": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name"
        }
      },
      "title": "Start the index using IndexStartConfig configuration"
    },
    "luceneserverStateRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to retrieve state"
        }
      },
      "title": "Input to state"
    },
    "luceneserverStateResponse": {
      "type": "object",
      "properties": {
        "response": {
          "type": "string",
          "title": "Json string of the current index state"
        }
      },
      "title": "Response from Server for state"
    },
    "luceneserverStatsRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to retrieve stats"
        }
      },
      "title": "Input to stats"
    },
    "luceneserverStatsResponse": {
      "type": "object",
      "properties": {
        "ord": {
          "type": "integer",
          "format": "int32",
          "title": "Shard ordinal"
        },
        "maxDoc": {
          "type": "integer",
          "format": "int32",
          "description": "The total number of docs in this index, including docs not yet flushed (still in the RAM buffer),\nnot counting deletions."
        },
        "numDocs": {
          "type": "integer",
          "format": "int32",
          "description": "The total number of docs in this index, including docs not yet flushed (still in the RAM buffer), and\nincluding deletions. NOTE: buffered deletions are not counted.  If you really need these to be\ncounted you should call {@link IndexWriter#commit()} first."
        },
        "dirSize": {
          "type": "string",
          "format": "int64",
          "title": "The total size of this indexDir"
        },
        "state": {
          "type": "string",
          "title": "The state of the index"
        },
        "taxonomy": {
          "$ref": "#/definitions/luceneserverTaxonomy",
          "title": "Taxonomy(facets) stats"
        },
        "searchers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/luceneserverSearcher"
          },
          "title": "Searcher stats"
        },
        "currentSearcher": {
          "$ref": "#/definitions/luceneserverSearcher",
          "title": "Current Searcher stats"
        }
      },
      "title": "Response from Server for stats"
    },
    "luceneserverStopIndexRequest": {
      "type": "object",
      "properties": {
        "indexName": {
          "type": "string",
          "title": "Index name to stop"
        }
      },
      "title": "Input to stopIndex"
    },
    "luceneserverTaxonomy": {
      "type": "object",
      "properties": {
        "numOrds": {
          "type": "integer",
          "format": "int32",
          "title": "Number of docs in this taxonomy reader"
        },
        "segments": {
          "type": "string",
          "title": "String representation of segments"
        }
      },
      "title": "Taxonomy stats"
    },
    "luceneserverTermInSetQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "textTerms": {
          "$ref": "#/definitions/TermInSetQueryTextTerms",
          "description": "TEXT terms to search for."
        },
        "intTerms": {
          "$ref": "#/definitions/TermInSetQueryIntTerms",
          "description": "INT terms to search for."
        },
        "longTerms": {
          "$ref": "#/definitions/TermInSetQueryLongTerms",
          "description": "LONG terms to search for."
        },
        "floatTerms": {
          "$ref": "#/definitions/TermInSetQueryFloatTerms",
          "description": "FLOAT terms to search for."
        },
        "doubleTerms": {
          "$ref": "#/definitions/TermInSetQueryDoubleTerms",
          "description": "DOUBLE terms to search for."
        }
      },
      "description": "Specialization for a disjunction over many terms that behaves like a ConstantScoreQuery over a BooleanQuery\ncontaining only BooleanClause.Occur.SHOULD clauses. Only ONE of the types of terms needs to be provided - the\none that matches the type of the field."
    },
    "luceneserverTermQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "textValue": {
          "type": "string",
          "title": "TEXT FieldType term to search for"
        },
        "intValue": {
          "type": "integer",
          "format": "int32",
          "title": "INT FieldType term to search for"
        },
        "longValue": {
          "type": "string",
          "format": "int64",
          "title": "LONG FieldType term to search for"
        },
        "floatValue": {
          "type": "number",
          "format": "float",
          "title": "FLOAT FieldType term to search for"
        },
        "doubleValue": {
          "type": "number",
          "format": "double",
          "title": "DOUBLE FieldType term to search for"
        },
        "booleanValue": {
          "type": "boolean",
          "title": "BOOLEAN FieldType term to search for"
        }
      },
      "title": "A query that matches documents containing a term"
    },
    "luceneserverTermRangeQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "The field to search"
        },
        "lowerTerm": {
          "type": "string",
          "title": "The lower bound of the range"
        },
        "upperTerm": {
          "type": "string",
          "title": "The upper bound of the range"
        },
        "includeLower": {
          "type": "boolean",
          "title": "Whether to include the lower bound in the range"
        },
        "includeUpper": {
          "type": "boolean",
          "title": "Whether to include the upper bound in the range"
        },
        "rewrite": {
          "$ref": "#/definitions/luceneserverRewriteMethod",
          "title": "Method used to rewrite the query"
        },
        "rewriteTopTermsSize": {
          "type": "integer",
          "format": "int32",
          "title": "Specifies the size to use for the TOP_TERMS* rewrite methods"
        }
      },
      "title": "Define a message for TermRangeQuery"
    },
    "luceneserverTermVectors": {
      "type": "string",
      "enum": [
        "NO_TERMVECTORS",
        "TERMS",
        "TERMS_POSITIONS",
        "TERMS_POSITIONS_OFFSETS",
        "TERMS_POSITIONS_OFFSETS_PAYLOADS"
      ],
      "default": "NO_TERMVECTORS",
      "description": "- NO_TERMVECTORS: No term vectors are indexed\n - TERMS: Index terms only\n - TERMS_POSITIONS: Index terms and positions\n - TERMS_POSITIONS_OFFSETS: Index terms, positions and offsets\n - TERMS_POSITIONS_OFFSETS_PAYLOADS: Index terms, positions, offsets and payloads",
      "title": "Whether/how term vectors should be indexed"
    },
    "luceneserverTermsCollector": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Use field values for terms"
        },
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Use FacetScript definition to produce terms"
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of top terms to return"
        },
        "order": {
          "$ref": "#/definitions/luceneserverBucketOrder",
          "title": "How results Buckets should be ordered, defaults to descending Bucket _count"
        }
      },
      "title": "Definition of term aggregating collector"
    },
    "luceneserverTextDocValuesType": {
      "type": "string",
      "enum": [
        "TEXT_DOC_VALUES_TYPE_UNSPECIFIED",
        "TEXT_DOC_VALUES_TYPE_BINARY",
        "TEXT_DOC_VALUES_TYPE_SORTED"
      ],
      "default": "TEXT_DOC_VALUES_TYPE_UNSPECIFIED",
      "description": "- TEXT_DOC_VALUES_TYPE_UNSPECIFIED: Unspecified doc values type, use field default\n - TEXT_DOC_VALUES_TYPE_BINARY: Binary doc values support text longer than 32766 bytes and are good when most values are unique or\nyou don't need to use sorting/aggregations on the field.\n - TEXT_DOC_VALUES_TYPE_SORTED: Sorted doc values only store values shorter than 32766 bytes and are better when many values are not unique.",
      "title": "Type of doc values to use for storing text values"
    },
    "luceneserverTopHitsCollector": {
      "type": "object",
      "properties": {
        "startHit": {
          "type": "integer",
          "format": "int32",
          "title": "Offset for retrieval of top hits"
        },
        "topHits": {
          "type": "integer",
          "format": "int32",
          "title": "Total hits to collect, note that the number of hits returned is (topHits - startHit)"
        },
        "querySort": {
          "$ref": "#/definitions/luceneserverQuerySortField",
          "title": "When specified, collector does sort based collection. Otherwise, relevance score is used"
        },
        "retrieveFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Which fields to retrieve"
        },
        "explain": {
          "type": "boolean",
          "title": "If Lucene explanation should be included in the collector response"
        }
      },
      "title": "Definition of top hits based collector"
    },
    "luceneserverTotalHits": {
      "type": "object",
      "properties": {
        "relation": {
          "$ref": "#/definitions/TotalHitsRelation"
        },
        "value": {
          "type": "string",
          "format": "int64",
          "description": "The value of the total hit count. Must be interpreted in the context of {#relation}."
        }
      },
      "title": "Query total hits"
    },
    "luceneserverTransferStatus": {
      "type": "object",
      "properties": {
        "Message": {
          "type": "string",
          "title": "Response message"
        },
        "Code": {
          "$ref": "#/definitions/luceneserverTransferStatusCode",
          "title": "Transfer status code"
        }
      },
      "title": "Response with transfer status"
    },
    "luceneserverTransferStatusCode": {
      "type": "string",
      "enum": [
        "Unknown",
        "Done",
        "Failed",
        "Ongoing"
      ],
      "default": "Unknown",
      "title": "Status of file copy"
    },
    "luceneserverVectorElementType": {
      "type": "string",
      "enum": [
        "VECTOR_ELEMENT_FLOAT",
        "VECTOR_ELEMENT_BYTE"
      ],
      "default": "VECTOR_ELEMENT_FLOAT",
      "description": "- VECTOR_ELEMENT_FLOAT: Single precision floating point\n - VECTOR_ELEMENT_BYTE: Signed byte",
      "title": "Vector field element type"
    },
    "luceneserverVectorIndexingOptions": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "title": "The vector indexing type, supports 'hnsw' and 'hnsw_scalar_quantized', default: hnsw"
        },
        "hnswM": {
          "type": "integer",
          "format": "int32",
          "title": "The number of neighbors each node will be connected to in the HNSW graph, default: 16"
        },
        "hnswEfConstruction": {
          "type": "integer",
          "format": "int32",
          "title": "The number of candidates to track while assembling the list of nearest neighbors for each new node, default: 100"
        },
        "mergeWorkers": {
          "type": "integer",
          "format": "int32",
          "title": "Number of threads to use for merging vector data, default: 1"
        },
        "quantizedConfidenceInterval": {
          "type": "number",
          "format": "float",
          "title": "The confidenceInterval for scalar quantizing the vectors. When unset, it is calculated based on the\nvector dimension. When `0`, the quantiles are dynamically determined by sampling many confidence intervals and\ndetermining the most accurate pair. Otherwise, the value must be between 0.9 and 1.0 (both inclusive).\ndefault: unset"
        },
        "quantizedBits": {
          "type": "integer",
          "format": "int32",
          "title": "The number of bits to use for quantizing the vectors. It can have the following values:\n     4 - half byte\n     7 - signed byte (default)"
        },
        "quantizedCompress": {
          "type": "boolean",
          "title": "Whether to compress the vectors, if true, the vectors that are quantized with \u003c= 4 bits will be compressed into\na single byte. If false, the vectors will be stored as is. This provides a trade-off of memory usage and speed.\ndefault: false"
        }
      },
      "title": "Options for indexing a VECTOR field for search"
    },
    "luceneserverVirtualField": {
      "type": "object",
      "properties": {
        "script": {
          "$ref": "#/definitions/luceneserverScript",
          "title": "Script defining this field's values"
        },
        "name": {
          "type": "string",
          "description": "Virtual field's name. Must be different from registered fields and any other virtual fields."
        }
      },
      "title": "Virtual field used during search"
    },
    "luceneserverWildcardQuery": {
      "type": "object",
      "properties": {
        "field": {
          "type": "string",
          "title": "Field in the document to query"
        },
        "text": {
          "type": "string",
          "title": "Pattern to search for"
        },
        "rewrite": {
          "$ref": "#/definitions/luceneserverRewriteMethod",
          "title": "Method used to rewrite the query"
        },
        "rewriteTopTermsSize": {
          "type": "integer",
          "format": "int32",
          "title": "Specifies the size to use for the TOP_TERMS* rewrite methods"
        }
      },
      "title": "A query that matches documents containing terms matching a pattern"
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    },
    "typeLatLng": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double",
          "description": "The latitude in degrees. It must be in the range [-90.0, +90.0]."
        },
        "longitude": {
          "type": "number",
          "format": "double",
          "description": "The longitude in degrees. It must be in the range [-180.0, +180.0]."
        }
      },
      "description": "An object that represents a latitude/longitude pair. This is expressed as a\npair of doubles to represent degrees latitude and degrees longitude. Unless\nspecified otherwise, this must conform to the\n\u003ca href=\"http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf\"\u003eWGS84\nstandard\u003c/a\u003e. Values must be within normalized ranges."
    }
  }
}
